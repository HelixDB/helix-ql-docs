---
title: 'MCP Guide'
description: 'A guide to get you started with HelixDB MCP Endpoints'
icon: 'rocket-launch'
---

---

# Introduction
...

Every time you want to create a traversal query that has a combination of MCP calls, you will need to pass in a connection ID.
If you are doing asynchonous calls, then it may be best to create a new connection ID for each traversal query.

---

# MCP Tools
These tools are used to manage the MCP connection and interact with the MCP endpoints.

<h2>Initialization `init`</h2>
<h4> Endpoint `"mcp/init"` </h4>
Creates a new MCP connection, which is a blank traversal.

Request Format
```rust
{"connection_id": "<connection-id>"}
```

Response Format
```rust
"<connection-id>"
```

<h2>Iterate Results `next`</h2>
<h4> Endpoint `"mcp/next"` </h4>
Returns the next item in the MCP traversal results.

Response Format
```rust
{<node-edge-data>}
```

<h2>Collect Results `collect`</h2>
<h4> Endpoint `"mcp/collect"` </h4>
Collects all the results from the MCP traversal.

Request Format
```rust
{
    "connection_id": "<connection-id>", 
    "range": {"start": <start-index>, "end": <end-index>}, 
    "drop" : <true-false>
}
```

Optional Parameters
- `range` (optional) : range of results to collect (default: `{"start": 0, "end": -1}`)
- `drop` (optional) : resets the traversal after collecting results (default: `true`)

Response Format
```rust
[
    {<node-edge-data>},
    ...
]
```

<h2>Reset Connection `reset`</h2>
<h4> Endpoint `"mcp/reset"` </h4>
Resets the MCP connection with the given connection ID to a blank traversal.

Request Format
```rust
{"connection_id": "<connection-id>"}
```

Response Format
```rust
"<connection-id>"
```

<h2>Schema Context `schema_resource`</h2>
<h4> Endpoint `"mcp/schema_resource"` </h4>
Returns the schema and query information of the database for LLM context.

Request Format
```rust
{"connection_id": "<connection-id>"}
```

Response Format
```rust expandable
{
    "schema": {
        "nodes": [
            {
                "name": "<node-name>",
                "properties": {
                    "<property-name>": "<property-type>",
                    ...
                }
            },
            ...
        ],
        "vectors": [
            {
                "name": "<vector-name>",
                "properties": {
                    "<property-name>": "<property-type>",
                    ...
                }
            },
            ...
        ],
        "edges": [
            {
                "name": "<edge-name>",
                "properties": {
                    "<property-name>": "<property-type>",
                    ...
                }
            },
            ...
        ]
    },
    "queries": [
        {
            "name": "<query-name>",
            "parameters": {
                "<parameter-name>": "<parameter-type>",
                ...
            },
            "returns": [
                "<return-variable-name>",
                ...
            ]
        }
    ]
}
```

---

# MCP Traversals
These tools are used to dynamically traverse the graph and retrieve nodes and edges.
However, they do not return the results of the traversal.

<h2>Retrieve Nodes `n_from_type`</h2>
<h4> Endpoint `"mcp/n_from_type"` </h4>
Retrieves all nodes of a given type.

Request Format
```rust
{"connection_id": "<connection-id>", "data": {"node_type": "<node-type>"}}
```

Parameters
- `node_type` : the type of node to retrieve

<h2>Retrieve Edges `e_from_type`</h2>
<h4> Endpoint `"mcp/e_from_type"` </h4>
Retrieves all edges of a given type.

Request Format
```rust
{"connection_id": "<connection-id>", "data": {"edge_type": "<edge-type>"}}
```

Parameters
- `edge_type` : the type of edge to retrieve

<h2>Out `out_step`</h2>
<h4> Endpoint `"mcp/out_step"` </h4>
Traverses out from current nodes or vectors in the traversal with the given edge type to nodes or vectors.
Assumes that the current state of the traversal is a collection of nodes or vectors that is the source of the given edge type and label.

Request Format
```rust
{
    "connection_id": "<connection-id>",
    "data": {"edge_type": "<edge-type>", "edge_label": "<edge-label>"}
}
```

Parameters
- `edge_type` : the type of edge to traverse out
- `edge_label` : the target entity (`node` or `vec`)

<h2>OutE `out_e_step`</h2>
<h4> Endpoint `"mcp/out_e_step"` </h4>
Traverses out from current edges to their target nodes or vectors.
Assumes that the current state of the traversal is a collection of edges with the target of the given edge label.

Request Format
```rust
{"connection_id": "<connection-id>", "data": {"edge_label": "<edge-label>"}}
```

Parameters
- `edge_label` : the target entity (`node` or `vec`)

<h2>In `in_step`</h2>
<h4> Endpoint `"mcp/in_step"` </h4>
Traverses into the current nodes or vectors in the traversal with the given edge type to nodes or vectors.
Assumes that the current state of the traversal is a collection of nodes or vectors that is the target of the given edge type and label.

Request Format
```rust
{
    "connection_id": "<connection-id>", 
    "data": {"edge_type": "<edge-type>", "edge_label": "<edge-label>"}
}
```

Parameters
- `edge_type` : the type of edge to traverse into
- `edge_label` : the source entity (`node` or `vec`)

<h2>InE `in_e_step`</h2>
<h4> Endpoint `"mcp/in_e_step"` </h4>
Traverses into the current edges to their source nodes or vectors.
Assumes that the current state of the traversal is a collection of edges with the source of the given edge label.

Request Format
```rust
{"connection_id": "<connection-id>", "data": {"edge_label": "<edge-label>"}}
```

Parameters
- `edge_label` : the source entity (`node` or `vec`)

---

# MCP Filter Tool

<h2>Filter `filter_items`</h2>
<h4> Endpoint `"mcp/filter_items"` </h4>
Filters the current state of the traversal.

Request Format
```rust
{
    "connection_id": "<connection-id>", 
    "data": {"filter": <filters>}
}
```

Where `filters` is a list of filters to apply to the current state of the traversal.
The format of the filters is as follows:

```rust
// Filter layer
{
    "properties" : [
        <property-filters>,
        ...
    ],
    "filter_traversals" : [
        <traversal-filters>,
        ...
    ]
}
```

### Property Filter
The property filter is used to filter the current state of the traversal by the properties of the entity.
The outer list is the `OR` operation and the inner list is the `AND` operation.    
```rust
// OR layer
"properties" : [
    // AND layer
    [
        // Filters
        {"key": "<property-name>", "operator": "<operator>", "value": "<property-value>"},
        ...
    ],
    ...
]
```

Parameters
- `key` : the name of the property to filter on
- `operator` : the operator to use for the filter
- `value` : the value to filter on

Operators:

| Operator | Description | Operator | Description |
|----------|-------------|----------|-------------|
| `==` | equals | `!=` | not equals |
| `>` | greater than | `>=` | greater than or equal to |
| `<` | less than | `<=` | less than or equal to |

<Note>
List to value and value to list comparisons will use the OR operator for each element in the list.      
List to list comparisons will also use the OR operator for each element in each list.  

This allows for using `contains` and `not_contains` operators by using the `==` and `!=` operator with a list of values.
</Note>

### Traversal Filter
The traversal filter is used to filter the current state of the traversal by the results of a traversal.
It doesn't actually change the state of the current traversal, it just temporarily traverses and checks the results of the traversal.
You can have nested filters in the inner filter layer, which can include property and traversal filters with the same structure.
The traversal filter only has an `AND` operation.

```rust
// AND layer
"filter_traversals" : [
    {
        // Traversal tool name
        "tool_name" : "<tool-name>",
        // Traversal tool args
        "args" : {
            "<parameter-name>" : "<parameter-value>",
            ...,
            // Inner filter layer
            "filter" : {
                "properties" : [
                    <property-filters>,
                    ...
                ],
                "filter_traversals" : [
                    <traversal-filters>,
                    ...
                ]
            }
        }
    },
    ...
]
```

---

# MCP Search Tools

<h2>SearchV `search_vector`</h2>
<h4> Endpoint `"mcp/search_vector"` </h4>
Searches for vectors by their vector representation with the given vector. 
It returns the top `k` results with a minimum score of `min_score`.
Additionally, you can continue the traversal from the search results by using the traversal tools.

Request Format
```rust
{
    "connection_id": "<connection-id>", 
    "data": {
        "vector": <array-of-floats>, "k": <limit>, "min_score": <min-score>
    }
}
```

Parameters
- `vector` : the vector to search for
- `k` : the number of results to return
- `min_score` (optional) : the minimum score to return (default: `0.0`)

Response Format
```rust
[
    {<vector-data>},
    ...
]
```

<h2>SearchV Text `search_vector_text`</h2>
<h4> Endpoint `"mcp/search_vector_text"` </h4>
Searches for vectors by their vector representation with given text.
It uses the embedding inside the database to embed the text and then does HNSW search for the vector.
It returns the top 5 results of the vectors with the `label`.

Request Format
```rust
{
    "connection_id": "<connection-id>", 
    "data": {
        "query": "<text>", "label": "<vector-label>"
    }
}
```

Parameters
- `query` : the text to search for
- `label` : the label of the vectors to search for

Response Format
```rust
[
    {<vector-data>},
    ...
]
```
<Warning>
The traversal will be reset after the search.
</Warning>

<h2>Search BM25 `search_keyword`</h2>
<h4> Endpoint `"mcp/search_keyword"` </h4>
Searches for nodes, edges, or vectors of the given label by their keyword representation using BM25.

Request Format
```rust
{
    "connection_id": "<connection-id>", 
    "data": {
        "query": "<text>", "label": "<label>", "limit": <limit>
    }
}
```

Parameters
- `query` : the text to search for
- `label` : the label of the nodes, edges, or vectors to search for
- `limit` : the number of results to return

Response Format
```rust
[
    {<node-edge-data>},
    ...
]
```

<Warning>
The traversal will be reset after the search.
</Warning>
---

# Knowledge Graph Examples
In this example, we will be using the Python SDK to interact with the MCP endpoints on a local instance of HelixDB.

We will use a knowledge graph with the schema below, which has 
a triplet node to represent a fact and an entity node to represent the subject and object of the triplet.
We will also have an embedding of the triplet's summary defined as a vector node.

Schema.hx
```rust expandable
N::Triplet {
    INDEX uuid: String,
    summary: String,
    predicate: String,
    value: String,
    created_at: Date DEFAULT NOW
}

E::Triplet_to_Embedding {
    From: Triplet,
    To: Triplet_Embedding,
    Properties: {
    }
}

V::Triplet_Embedding {
    embedding: [F64]
}

E::Triplet_to_Subject {
    From: Triplet,
    To: Entity,
    Properties: {
    }
}

E::Triplet_to_Object {
    From: Triplet,
    To: Entity,
    Properties: {
    }
}

N::Entity {
    INDEX uuid: String,
    name: String,
    entity_type: String,
    description: String,
    created_at: Date DEFAULT NOW
}
```

Python SDK
```py
from helix import Client
client = Client(local=True, port=6969)
```

<Tip>
Click [here](../documentation/sdks/helix-py) for more information about the Python SDK.       
</Tip>

### 1. Filter properties by a list of values.
We will filter the entities with the names "John" or "Jane".

```py expandable
# Initialize the connection
connection_id = client.query('mcp/init', {})[0]

# Get all entities
client.query('mcp/n_from_type', {'connection_id': connection_id, 'data': {'node_type': 'Entity'}})

# Filter entities by the name "John" or "Jane"
client.query('mcp/filter_items', {
    'connection_id': connection_id, 
    'data': {'filter': {
        'properties': [
            [
                {'key': 'name', 'operator': '==', 'value': ['John', 'Jane']}
            ]
        ]
    }}
})

# Collect the entities
entities = client.query('mcp/collect', {'connection_id': connection_id})[0]
```

### 2. Filter multiple properties by a list of values.
We will filter the entities with the names "John" or "Jane" and the created_at property between 2025-01-01 and 2025-01-31.

```py expandable
# Initialize the connection
connection_id = client.query('mcp/init', {})[0]

# Get all entities
client.query('mcp/n_from_type', {'connection_id': connection_id, 'data': {'node_type': 'Entity'}})

# Filter entities by the name "John" or "Jane" and the created_at property between 2025-01-01 and 2025-01-31
client.query('mcp/filter_items', {
    'connection_id': connection_id, 
    'data': {'filter': {
        'properties': [
            [
                # AND layer
                {'key': 'name', 'operator': '==', 'value': ['John', 'Jane']},
                {'key': 'created_at', 'operator': '>=', 'value': "2025-01-01T00:00:00+00:00"},
                {'key': 'created_at', 'operator': '<=', 'value': "2025-01-31T23:59:59+00:00"}
            ]
        ]
    }}
})
```

### 3. Filter properties by multiple lists of values.
We will filter by date range of the `created_at` property from January to March or June to September.

```py expandable
# Initialize the connection
connection_id = client.query('mcp/init', {})[0]

# Get all entities
client.query('mcp/n_from_type', {'connection_id': connection_id, 'data': {'node_type': 'Entity'}})

# Filter entities by the created_at property between January and March or June and September
client.query('mcp/filter_items', {
    'connection_id': connection_id, 
    'data': {'filter': {
        'properties': [
            # OR layer
            [
                # AND layer
                {'key': 'created_at', 'operator': '>=', 'value': "2025-01-01T00:00:00+00:00"},
                {'key': 'created_at', 'operator': '<=', 'value': "2025-03-31T23:59:59+00:00"}
            ],
            [
                # AND layer
                {'key': 'created_at', 'operator': '>=', 'value': "2025-06-01T00:00:00+00:00"},
                {'key': 'created_at', 'operator': '<=', 'value': "2025-09-30T23:59:59+00:00"}
            ]
        ]
    }}
})

# Collect the entities
entities = client.query('mcp/collect', {'connection_id': connection_id})[0]
```

### 3. Filter by traversal result properties.
We will filter the triplets connected to the subject name "John".   
This example has 2 answers:

```py expandable
# Initialize the connection
connection_id = client.query('mcp/init', {})[0]

# Get all entities
client.query('mcp/n_from_type', {'connection_id': connection_id, 'data': {'node_type': 'Entity'}})

# Filter entities by the name "John"
client.query('mcp/filter_items', {
    'connection_id': connection_id, 
    'data': {'filter': {
        'properties': [
            [
                {'key': 'name', 'operator': '==', 'value': 'John'}
            ]
        ]
    }}
})

# Get all triplets connected to the entities
# (traverses the In of the edge to triplet nodes connected to the entities)
client.query('mcp/in_step', {"connection_id": connection_id, "data": {"edge_type": "Triplet_to_Subject", "edge_label": "node"}})

# Collect the triplets
triplets = client.query('mcp/collect', {'connection_id': connection_id})[0]
```

OR

```py expandable
# Initialize the connection
connection_id = client.query('mcp/init', {})[0]

# Get all triplets
client.query('mcp/n_from_type', {'connection_id': connection_id, 'data': {'node_type': 'Triplet'}})

# Filter triplets with the subject name "John"
client.query('mcp/filter_items', {
    'connection_id': connection_id, 
    'data': {'filter': {
        'filter_traversals': [
            # Traverse out from the triplet nodes to the subject nodes
            {
                'tool_name': 'out_step',
                'args': {
                    'edge_type': 'Triplet_to_Subject',
                    'edge_label': 'node'
                },
                # Filter the subject nodes by the name "John"
                'filters': {
                    'properties': [
                        [
                            {'key': 'name', 'operator': '==', 'value': 'John'}
                        ]
                    ]
                }
            }
        ]
    }}
})

# Collect the triplets
triplets = client.query('mcp/collect', {'connection_id': connection_id})[0]
```

### 4. Filter by multiple traversal results.
We will filter the triplets connected to the subject name "John" and the object name "Jane".

```py expandable
# Initialize the connection
connection_id = client.query('mcp/init', {})[0]

# Get all triplets
client.query('mcp/n_from_type', {'connection_id': connection_id, 'data': {'node_type': 'Triplet'}})

# Filter the triplets by the subject name "John" and the object name "Jane"
client.query('mcp/filter_items', {'connection_id': connection_id, 'data': {'filter': {
    'filter_traversals': [
        # AND layer
        # Traverse out from the triplet nodes to the subject nodes
        {
            'tool_name': 'out_step',
            'args': {
                'edge_type': 'Triplet_to_Subject',
                'edge_label': 'node'
            },
            # Filter the subject nodes by the name "John"
            'filters': {
                'properties': [
                    [
                        {'key': 'name', 'operator': '==', 'value': 'John'}
                    ]
                ]
            }
        },
        # Traverse out from the triplet nodes to the object nodes
        {
            'tool_name': 'out_step',
            'args': {
                'edge_type': 'Triplet_to_Object',
                'edge_label': 'node'
            },
            # Filter the object nodes by the name "Jane"
            'filters': {
                'properties': [
                    [
                        {'key': 'name', 'operator': '==', 'value': 'Jane'}
                    ]
                ]
            }
        }
    ]
}}})

# Collect the triplets
triplets = client.query('mcp/collect', {'connection_id': connection_id})[0]
```

### 5. Collecting intermediate results.
We will get all triplets and their embeddings in one MCP connection.

```py expandable
# Initialize the connection
connection_id = client.query('mcp/init', {})[0]

# Get all triplets
client.query('mcp/n_from_type', {'connection_id': connection_id, 'data': {'node_type': 'Triplet'}})

# Collect without resetting
triplets = client.query('mcp/collect', {'connection_id': connection_id, "drop": False})[0]

# Traverse out from the triplets to the embeddings
client.query('mcp/out_step', {'connection_id': connection_id, 'data': {'edge_type': 'Triplet_to_Embedding', 'edge_label': 'vec'}})

# Collect the embeddings
embeddings = client.query('mcp/collect', {'connection_id': connection_id})[0]
```

### 6. Search by vector.
We will search for the top 10 triplets that are most similar to an example embedding of `[0.1, 0.2, 0.3, 0.4, 0.5]` with a minimum score of 0.7.

```py expandable
# Initialize the connection
connection_id = client.query('mcp/init', {})[0]

# Get all triplets
client.query('mcp/n_from_type', {'connection_id': connection_id, 'data': {'node_type': 'Triplet'}})

# Traverse to embeddings
client.query('mcp/out_step', {'connection_id': connection_id, 'data': {'edge_type': 'Triplet_to_Embedding', 'edge_label': 'vec'}})

# Search for the triplets that are most similar to an example embedding of [0.1, 0.2, 0.3, 0.4, 0.5]
client.query('mcp/search_vector', {'connection_id': connection_id, 'data': {'vector': [0.1, 0.2, 0.3, 0.4, 0.5], 'limit': 10, 'min_score': 0.7}})

# Traverse to the triplets
client.query('mcp/in_step', {'connection_id': connection_id, 'data': {'edge_type': 'Triplet_to_Embedding', 'edge_label': 'node'}})

# Collect the triplets
triplets = client.query('mcp/collect', {'connection_id': connection_id})[0]
```
