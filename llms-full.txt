---
title: HelixDB Guide Full
last_updated: 2026-02-19
audience: LLM agents
---

# HelixDB Overview
@tags: intro, architecture, helixdb, graph, vector

## TL;DR
- High Performance: Purpose-built storage engine optimized for both graph and vector operations
- Graph-Vector Hybrid: Store both graph and vector data in the same database (less overhead than separate databases)
- Query Language: Designed for traversing and manipulating graph and vector data efficiently
- Type Safety: Explicit type definitions to ensure data integrity
- Developer-Friendly: Simple setup and migration
- Secure: Options for encryption at rest

## Data Model
- **Nodes**: entities with unique identifiers and properties  
- **Vectors** – entities with unique identifiers and vector embeddings  
- **Edges** - directed relationships between nodes and/or vectors, carrying properties  

## Common Use Cases
1. **Social Networks** – friend graphs, content sharing, community detection  
2. **Recommendation Engines** – product/content suggestions, “people you may know”, interest matching  
3. **Fraud Detection** – transaction pattern recognition, suspicious-relationship analysis, risk scoring  
4. **Knowledge Graphs** – semantic search, data integration, ML feature store, research discovery  

## When to Use a Graph Database
- Data contains dense, interconnected relationships  
- Queries require multi-hop traversals or pattern matching  
- Traditional SQL joins become complex or slow  
- Hierarchical structures or path finding dominate access patterns 

## Benefits Over Traditional Databases
- **Performance**: Faster for relationship-heavy queries
- **Flexibility**: Easier to modify and extend the data model
- **Intuitive**: More natural way to model connected data
- **Scalability**: Better handling of complex relationship patterns

# Installation
@tags: install, cli, setup, docker, prerequisites, quickstart

## Prerequisites
- Rust version 1.88.0 or higher (required)
- Docker Desktop for local development (required)
- Git for first-time Helix source cache (required)
- Cloud CLIs: AWS CLI, Fly CLI for cloud deployment (optional)

## Install Steps

1. **Install Helix CLI**
   ```bash
   curl -sSL https://install.helix-db.com | bash
   ```
   Note: Run `helix update` to upgrade; `helix migrate` to migrate existing projects from CLI v1 to CLI v2.

2. **Create project**
   ```bash
   helix init
   ```
   Creates a new project in the current directory with `helix.toml` file and `db` directory containing `schema.hx` and `queries.hx` files.
   Read the `helix.toml` file for more information about the configuration.

3. **Define schema and queries**
    Define the [schema and queries](#helix-query-language) in the `schema.hx` and `queries.hx` files in the `db` directory.
    There will be default schema and queries commented out at the top of the files for you.

4. **Build and deploy locally**
    Build and deploy the project to the local HelixDB instance.
    ```bash
    helix push dev
    ```
    Replace `<dev>` with the actual name of the instance.
    Check the [CLI commands](#commands) for more information about the build and deploy process.
    Once Helix CLI is installed and your instance is initialized, continue to [configurations](#configurations) to customize ports and instances or jump to [HelixDB SDKs](#helix-software-development-kits-sdks) or cURL to test your first query.

5. **Test connection**
    - If you are using a local HelixDB instance, verify that it now runs inside Docker on port designated in the `helix.toml` file (usually `6969`).
    - Calling a query in the `queries.hx` file should return the expected result. Replace `<port>`, `<query_name>`, and `<parameter_name>` with the actual port, query name, and parameter name. Remember to run create query first before running read, update, delete queries.
    ```bash
    curl -X POST http://localhost:<port>/<query_name> \
      -H "Content-Type: application/json" \
      -d '{<parameter_name>: <parameter_value>, ...}'
    ```

## Best Practices

- **Development**
  - Run `helix check` before every deploy
  - Use descriptive instance names
  - Keep dev/prod configs separate
  - Clean unused resources with `helix prune`
  - Version-control `helix.toml`

- **Production**
  - Set `build_mode = "release"`
  - Tune vector parameters to data scale
  - Enable monitoring & logging
  - Automate backups
  - Test migrations in staging first

- **Security**
  - Never commit credentials
  - Use env vars for secrets
  - Rotate API keys regularly
  - Keep CLI updated: `helix update`
  - Use private instances for prod data

# HelixDB CLI V2
@tags: cli, commands, reference, v2, management

## TL;DR
- Complete CLI: All commands for managing HelixDB instances and projects
- Multi-platform: Local Docker, Fly.io, AWS ECR, and Helix Cloud support
- Project lifecycle: init → check → build → push → monitor → stop
- Instance types: Local development, cloud staging, production deployments
- Migration support: Built-in v1 to v2 project migration tools

## Commands

### Global Options
- `--help, -h` - Show help information for the command
- `--version, -V` - Display the CLI version

### Project Management

#### `helix init`
Initialize a new Helix project with configuration and structure.

**Usage:** `helix init [OPTIONS] [SUBCOMMAND]`

**Options:**
- `--path, -p [PATH]` - The path to the project
- `--template [TEMPLATE]` - The template to use for the project
- `--queries-path, -q [PATH]` - The path to the query files

**Subcommands:**
- `helix init cloud [OPTIONS]` - Initialize cloud instance
  - `--region [REGION]` - The region the instance is deployed to
  - `--name [NAME]` - The name of the instance
- `helix init ecr [OPTIONS]` - Initialize AWS ECR instance
  - `--name [NAME]` - The name of the AWS ECR repository (creates if needed)
- `helix init fly [OPTIONS]` - Initialize Fly.io instance
  - `--name [NAME]` - The name of the Fly.io app
  - `--volume-size` - The volume size in GB
  - `--vm-size [SIZE]` - VM size options:
    - `shared-cpu-1x` - 1 shared vCPU, 256MB RAM
    - `shared-cpu-2x` - 2 shared vCPUs, 512MB RAM
    - `shared-cpu-4x` - 4 shared vCPUs, 1GB RAM
    - `performance-4x` - 4 dedicated vCPUs, 8GB RAM
    - `performance-8x` - 8 dedicated vCPUs, 16GB RAM
  - `--public` - Make instance public
- `helix init local [OPTIONS]` - Initialize local instance
  - `--name [NAME]` - The name of the local instance

**Note:** `helix init` with no arguments defaults to making a local instance called `dev`.

#### `helix add`
Add a new instance to an existing Helix project.

**Usage:** `helix add [SUBCOMMAND]`

**Subcommands:**
- `helix add cloud [OPTIONS]` - Add cloud instance
  - `--region [REGION]` - The region the instance is deployed to
  - `--name [NAME]` - The name of the instance
- `helix add ecr [OPTIONS]` - Add AWS ECR instance
  - `--name [NAME]` - The name of the AWS ECR repository (creates if needed)
- `helix add fly [OPTIONS]` - Add Fly.io instance
  - `--name [NAME]` - The name of the Fly.io app
  - `--volume-size` - The volume size in GB
  - `--vm-size [SIZE]` - VM size options (same as `helix init fly`)
  - `--public` - Make instance public
- `helix add local [OPTIONS]` - Add local instance
  - `--name [NAME]` - The name of the local instance

#### `helix migrate`
Migrate a v1 Helix project to v2 format.

**Usage:** `helix migrate [OPTIONS]`

**Options:**
- `--path, -p [PATH]` - The path to the project to migrate (default: current directory)
- `--queries-dir, -q [DIR]` - The directory to move .hx files to (default: "./db/")
- `--instance-name, -i [NAME]` - The name for the default local instance (default: "dev")
- `--port [PORT]` - The port for the local instance (default: 6969)
- `--dry-run` - Show what would be migrated without making changes
- `--no-backup` - Skip creating backup of v1 files

### Validation & Compilation

#### `helix check`
Validate project configuration and query syntax.

**Usage:** `helix check [INSTANCE]`
- `[INSTANCE]` - Name of the instance to check (defaults to all instances)

#### `helix compile`
Compile project queries into executable format.

**Usage:** `helix compile [OPTIONS]`

**Options:**
- `--path, -p [PATH]` - The path to the project
- `--output, -o [PATH]` - The output path for compiled queries

#### `helix build`
Build and prepare an instance for deployment.

**What it does:**
1. Validates configuration and queries
2. Compiles queries
3. Generates Docker configuration files
4. Prepares the instance workspace

**Usage:** `helix build [INSTANCE]`
- `[INSTANCE]` - The instance to build

### Deployment & Instance Management

#### `helix push`
Deploy or update a running instance.

**What it does:**
1. Builds the instance if needed
2. Creates/updates Docker container for local instances
3. Pushes to cloud provider for remote instances
4. Starts the instance

**Usage:** `helix push [INSTANCE]`
- `[INSTANCE]` - The instance to deploy

#### `helix pull`
** COMING SOON **

#### `helix start`
Start a stopped instance without rebuilding.

**Usage:** `helix start [INSTANCE]`
- `[INSTANCE]` - The instance to start

#### `helix stop`
Stop a running instance.

**Usage:** `helix stop [INSTANCE]`
- `[INSTANCE]` - The instance to stop

#### `helix status`
Show the status of all instances in the project.

### Cleanup & Maintenance

#### `helix prune`
Remove unused containers, images, and workspace files.

**What it removes:**
- Stopped containers
- Unused Docker images
- Workspace files
- **Note:** Preserves data volumes

**Usage:** `helix prune [OPTIONS] [INSTANCE]`
- `[INSTANCE]` - The instance to prune
- `--all, -a` - Prune all instances in the project

#### `helix delete`
Permanently delete an instance and all its data.

**What it removes:**
- Container and images
- All data volumes
- Workspace files
- Configuration entries

**Usage:** `helix delete [INSTANCE]`
- `[INSTANCE]` - The instance to delete

### Authentication & Cloud

#### `helix auth`
Manage authentication for Helix Cloud.

**Usage:** `helix auth [SUBCOMMAND]`

**Subcommands:**
- `login` - Initiates browser-based authentication flow
- `logout` - Clears authentication tokens from `~/.helix/credentials`
- `create-key` - Generates a new API key for programmatic access

### Configuration & Settings

#### `helix metrics`
Configure telemetry and usage metrics collection.

**Usage:** `helix metrics [SUBCOMMAND]`

**Subcommands:**
- `full` - Enable full metrics collection (requires email)
- `basic` - Enable minimal anonymous metrics
- `off` - Disable all metrics collection
- `status` - Show current metrics configuration

#### `helix update`
Update the Helix CLI to the latest version.

**Usage:** `helix update [OPTIONS]`

**Options:**
- `--force` - Force update even if already on latest version

### Support
- **GitHub Issues:** https://github.com/HelixDB/helix-db/issues
- **Discord:** https://discord.gg/2stgMPr5BD
- **Email:** founders@helix-db.com

## Configurations
@tags: config, toml, settings, deployment, reference

### TL;DR
- Central config: Single `helix.toml` file manages all project settings
- Multi-environment: Local dev, staging, production configurations in one file
- Flexible deployment: Support for Docker, Fly.io, AWS ECR, and Helix Cloud
- Vector tuning: Configurable HNSW parameters for different data scales
- Build modes: Debug, release, and dev modes for different use cases

### Configuration File Structure

The `helix.toml` file is the central configuration for your Helix project, defining project metadata, instance configurations, and deployment settings.

#### Basic Structure

```toml
[project]
name = "my-helix-app"
queries = "./db/"

[local.dev]
# Local instance configuration

[cloud.staging.fly]
# Fly.io instance configuration

[cloud.production.helix]
# Cloud instance configuration
```

### Project Configuration

The `[project]` section defines global project settings:

```toml
[project]
name = "my-helix-app"        # Project name (required)
queries = "./db/"            # Path to query files (default: "./db/")
```

### Local Instance Configuration

Local instances use Docker for containerized development environments.

#### Basic Local Configuration

```toml
[local.dev]
port = 6969                  # Port for the instance (default: 6969)
build_mode = "dev"         # Build mode: debug | release (default: debug)
mcp = true                   # Enable MCP support (default: false)
bm25 = true                  # Enable BM25 search (default: false)
```

#### Advanced Local Settings

```toml
[local.dev]
port = 6969
build_mode = "release"
mcp = true
bm25 = true
```

#### Multiple Local Instances

You can define multiple local instances for different purposes:

```toml
[local.dev]
port = 6969
build_mode = "dev"

[local.testing]
port = 7070
build_mode = "dev"

[local.benchmark]
port = 8080
build_mode = "release"
```

### Cloud Instance Configuration

#### Helix Cloud

```toml
[cloud.production.helix]
cluster_id = "hlx_abc123"    # Cluster ID given to you by us (contact us if you don't have yours)
build_mode = "release"       # Build optimization
mcp = true
bm25 = true

[cloud.production.helix.vector_config]
m = 32
ef_construction = 256
ef_search = 1024
db_max_size_gb = 100
```

#### AWS ECR Configuration

```toml
[cloud.staging.ecr]
repository_name = "my-helix-app"
region = "us-east-1"
registry_url = "123456789.dkr.ecr.us-west-2.amazonaws.com"
auth_type = "aws_cli"
build_mode = "dev"
```

#### Fly.io Configuration

```toml
[cloud.production.fly]
app_name = "my-helix-app"
build_mode = "dev"        # Fly.io region
vm_size = "shared-cpu-4x"   # VM size
volume_initial_size = 20            # Volume size in GB
private = false              # Public accessibility
auth_type = "cli"                # Auth type: cli | api_key
```

### Build Modes

Build modes control optimization and debugging capabilities:

```toml
build_mode = "dev"    # Development with debug symbols
build_mode = "release"  # Production optimized
build_mode = "dev"      # For use with the dashboard UI
```

#### Mode Characteristics

```json
{
  "`debug`": { "debug_symbols": true, "cargo_optimizations": "none", "logging": "verbose", "use_case": "development", "dashboard_compatible": false },
  "`release`": { "debug_symbols": false, "cargo_optimizations": "full", "logging": "normal", "use_case": "production", "dashboard_compatible": false },
  "`dev`": { "debug_symbols": true, "cargo_optimizations": "none", "logging": "verbose", "use_case": "development", "dashboard_compatible": true }
}
```

### Common Issues

1. **Port conflicts**: Ensure unique ports for each local instance
2. **Missing credentials**: Run `helix auth login` for cloud features
3. **Invalid paths**: Use relative paths from project root
4. **Memory limits**: Adjust `db_max_size_gb` based on available RAM

## Workflows
@tags: workflows, development, deployment, devops, patterns

### TL;DR
- Local-first: Start with local Docker development, scale to cloud
- Environment progression: dev → staging → production with isolated configs
- CI/CD ready: Scriptable commands for automated deployments
- Multi-instance: Run multiple environments simultaneously on different ports
- Cloud options: Deploy to Fly.io, AWS ECR, or Helix Cloud with same commands

### Local Development

#### Initial Setup

1. Create a new project
    ```bash
    mkdir my-app && cd my-app
    helix init
    ```
    Note: `helix init` with no arguments defaults to making a local instance called `dev`.

2. Define schema and queries
    Edit `db/schema.hx` and `db/queries.hx`.

3. Validate
    Check the project configuration and query syntax.
    ```bash
    helix check
    ```

4. Build and deploy
    Build and deploy the project to the local HelixDB instance.
    ```bash
    helix push dev
    ```

#### Development Iteration

When making changes during development:

1. Edit your .hx files
2. Validate changes: `helix check`
3. Build and deploy: `helix push dev`
4. Check status: `helix status`
5. View logs: `docker logs <docker_container_name>`
6. Stop when done: `helix stop dev`

#### Working with Multiple Instances

Create different instances for different purposes:

```bash
# Add a new instance
helix add local --name <instance_name>

# Run multiple instances
helix push dev
helix push <instance_name>

# Check all instances
helix status
```

**Environment separation in `helix.toml`:**
```toml
[local.dev]
port = 6969
build_mode = "dev"

[local.testing]
port = 7070
build_mode = "dev"

[local.prod-like]
port = 8080
build_mode = "release"
```

### Cloud Deployment

Cloud deployment supports three platforms with the same workflow pattern:
- **Helix Cloud**: Managed service (contact team for cluster)
- **Fly.io**: Container platform
- **AWS ECR**: Container registry for ECS/EKS

#### Universal Setup Pattern

1. **Add cloud instance**
   ```bash
   # Helix Cloud
   helix add cloud --name <instance_name>
   
   # Fly.io
   helix add fly --name <instance_name>
   
   # AWS ECR
   helix add ecr --name <instance_name>
   ```

2. **Configure platform-specific settings** in `helix.toml`:

   **Helix Cloud:**
   ```toml
   [cloud.<instance_name>.helix]
   cluster_id = "REPLACE_WITH_YOUR_CLUSTER_ID"
   region = "us-east-1"
   build_mode = "release"
   mcp = true
   bm25 = true
   
   [cloud.<instance_name>.helix.vector_config]
   m = 32
   ef_construction = 256
   ef_search = 1024
   ```

   **Fly.io:**
   ```toml
   [cloud.<instance_name>.fly]
   app_name = "my-helix-app"
   build_mode = "release"
   vm_size = "shared-cpu-4x"
   volume_initial_size = 20
   private = false
   auth_type = "cli"
   ```

   **AWS ECR:**
   ```toml
   [cloud.<instance_name>.ecr]
   repository_name = "my-helix-app"
   region = "us-east-1"
   registry_url = "123456789.dkr.ecr.us-west-2.amazonaws.com"
   auth_type = "aws_cli"
   build_mode = "release"
   ```

3. **Deploy**
   ```bash
   helix push <instance_name>
   ```

4. **Monitor**
   ```bash
   helix status
   ```

#### Platform-Specific Prerequisites

**Helix Cloud:**
- Authenticate: `helix auth login`
- **Warning:** Contact HelixDB team to create new clusters

**Fly.io:**
- Install `flyctl`:
  ```bash
  # macOS
  brew install flyctl
  # or
  curl -L https://fly.io/install.sh | sh
  
  # Linux
  curl -L https://fly.io/install.sh | sh
  
  # Windows
  pwsh -Command "iwr https://fly.io/install.ps1 -useb | iex"
  ```
- Authenticate: `fly auth login`

**AWS ECR:**
- Configure AWS CLI: `aws configure`
- **Warning:** Ensure AWS CLI has necessary ECR permissions

#### Environment Progression Pattern

**Configuration example for all platforms:**
```toml
# Local development
[local.dev]
port = 6969
build_mode = "dev"

# Staging environments
[cloud.staging.helix]
cluster_id = "hlx_staging_xyz789"
region = "us-east-1"
build_mode = "dev"

[cloud.staging.fly]
app_name = "my-helix-app-staging"
build_mode = "dev"
vm_size = "shared-cpu-2x"
volume_initial_size = 15

[cloud.staging.ecr]
repository_name = "my-helix-app-staging"
region = "us-east-1"
registry_url = "123456789.dkr.ecr.us-west-2.amazonaws.com"
build_mode = "dev"

# Production environments
[cloud.production.helix]
cluster_id = "hlx_prod_xyz789"
region = "us-east-1"
build_mode = "release"
```

**Deployment workflow:**
```bash
# Test locally first
helix push dev

# Deploy to staging
helix push staging

# After testing, deploy to production
helix push production
```

#### Platform-Specific Management

**Helix Cloud:**
- Scaling: Contact support for cluster scaling
- Security: Use private clusters, rotate API keys with `helix auth create-key`

**Fly.io:**
- Check status: `fly status -a <app_name>`
- View logs: `fly logs -a <app_name>`
- Security: Use private apps, monitor resource usage

**AWS ECR:**
- Repository management:
  ```bash
  aws ecr describe-repositories
  aws ecr delete-repository --repository-name my-helix-app --force
  ```
- Security: Use IAM roles with least privilege, enable lifecycle policies

## Migration from CLI V1 to CLI V2
@tags: migration, upgrade, v1, v2, legacy

### TL;DR
- One-command upgrade: `helix migrate` converts v1 projects automatically
- Safe migration: Creates backups by default, dry-run option available
- File reorganization: `config.hx.json` → `helix.toml`, queries → `db/` directory
- Zero downtime: Test locally before deploying migrated configurations
- Backward compatible: Existing queries and schemas work unchanged

For users who are using the CLI V1, you can migrate your project to the CLI V2 by following the steps below.

#### Migration Steps

1. Find and enter V1 project
    ```bash
    cd path-to-v1-project
    ```
    **Note:** The path should be to the directory containing the old `config.hx.json` file.

2. Migrate project
    ```bash
    helix migrate
    ```
    This will migrate your project to v2 format.

#### Migration Details

##### What gets migrated
- `config.hx.json` → `helix.toml`
- Query files → `db/queries.hx`
- Schema files → `db/schema.hx`
- Instance configurations → `helix.toml` sections

##### Backup creation
By default, `helix migrate` creates backups of your v1 files. Use `--no-backup` to skip this.

##### Dry run option
Use `--dry-run` to see what would be migrated without making changes:
```bash
helix migrate --dry-run
```

#### Post-migration checklist

1. Review helix.toml
   Check the generated configuration file for accuracy.

2. Test locally
   ```bash
   helix check
   helix push <instance_name>
   ```

3. Update deployment scripts
   Update any CI/CD scripts to use v2 commands.

4. Update documentation
   Update any internal documentation to reference v2 commands and configuration.


## Troubleshooting
@tags: troubleshooting, errors, fixes, debug, logs, docker, auth, network, migration, performance, common-errors

### TL;DR
- Installation issues: Ensure PATH is updated, use sudo if needed
- Configuration issues: Check if you are in the correct project directory, check the `helix.toml` file
- Docker issues: Start Docker Desktop, add user to docker group, use different port
- Authentication issues: Run `helix auth login` to authenticate
- Build & deployment issues: Check if queries directory exists, check port binding
- Migration issues: Run `helix migrate --dry-run` to see what would be migrated without making changes
- Performance issues: Use release mode for production only, reduce vector config for development, clean Docker cache
- Network issues: Check if container is running, test localhost connection, check firewall settings

### Installation Issues

#### After installation, helix command is not recognized.
##### Error: command not found: helix
##### Solution:
1. Ensure PATH is updated (Bash):
```bash
echo 'export PATH="$HOME/.helix/bin:$PATH"' >> ~/.bashrc
source ~/.bashrc
```
2. Ensure PATH is updated (Zsh):
```bash
echo 'export PATH="$HOME/.helix/bin:$PATH"' >> ~/.zshrc
source ~/.zshrc
```
3. Verify installation:
```bash
ls -la ~/.helix/bin/helix
```

#### Permission denied during installation 
##### Error: installation fails with permission errors.
##### Solution:
Use system-wide installation with sudo
```bash
curl -fsSL https://raw.githubusercontent.com/HelixDB/helix-db/main/install.sh | sudo bash -- --system
```

### Project Configuration Issues

#### Not in a Helix project directory
##### Error: Not in a Helix project directory. Run `helix init` to create one.
##### Solution:
1. Check if you are in the correct project directory.

2. Check if the `helix.toml` file exists.
```bash
cd path-to-your-project
ls helix.toml
```

3. If not found, create a new project with `helix init`.
```bash
helix init
```

#### Invalid configuration in helix.toml
##### Error: Failed to parse helix.toml: invalid type: string "6969", expected u16
##### Solution:
Ensure port numbers are integers without quotes
```toml
# Wrong
[local.dev]
port = "6969"

# Correct
[local.dev]
port = 6969
```

#### Instance not found
##### Error: Instance 'production' not found in configuration
##### Solution:
1. Check available instances with `helix status`.
```bash
helix status
```

2. If not found, add the missing instance with `helix add <instance_type> --name <instance_name>`.
```bash
helix add <instance_type> --name <instance_name> [OPTIONS]
```

### Docker Issues

#### Docker daemon not running
##### Error: Cannot connect to Docker daemon. Is the Docker daemon running?
##### Solution:
1. For macOS/Windows, start Docker Desktop. For Linux, start Docker daemon (sudo systemctl start docker).
```bash
# Start Docker Desktop (macOS/Windows)

# Linux
sudo systemctl start docker
```

2. Verify Docker is running
```bash
docker info
```

#### Permission denied for Docker socket
##### Error: permission denied while trying to connect to the Docker daemon socket
##### Solution:
Add user to docker group
```bash
sudo usermod -aG docker $USER
newgrp docker
```

#### Port already in use
##### Error: bind: address already in use
##### Solution:
1. Find process using the port
```bash
lsof -i :6969
```
2. Stop conflicting service or use different port
```toml
[local.dev]
port = 7070
```

#### Container name conflict
##### Error: Container name "/helix_my-app_dev" is already in use
##### Solution:
1. Check if container is running/in use
```bash
docker ps -a | grep helix_my-app_dev
```

2. Remove old container
```bash
docker rm helix_my-app_dev
# Or force remove
docker rm -f helix_my-app_dev
```

### Authentication Issues

#### Helix Cloud authentication failed
##### Error: Credentials file not found. Please run 'helix auth login' first.
##### Solution:
Run `helix auth login` to authenticate.
```bash
helix auth login
```

#### Expired credentials
##### Error: Authentication token expired
##### Solution:
Re-authenticate
```bash
helix auth logout
helix auth login
```

#### Fly.io authentication issues
##### Error: Error authenticating with Fly.io
##### Solution:
Run CLI auth to authenticate.
```bash
flyctl auth login
```

#### AWS ECR authentication failed
##### Error: no basic auth credentials
##### Solution:
1. Configure AWS CLI
```bash
aws configure
```

2. Login to ECR
```bash
aws ecr get-login-password --region us-west-2 | \
  docker login --username AWS --password-stdin \
  123456789.dkr.ecr.us-west-2.amazonaws.com
```

### Build & Deployment Issues

#### Build fails with missing files
##### Error: Failed to copy queries: No such file or directory
##### Solution:
Ensure queries directory exists
```bash
mkdir -p db
touch db/schema.hx db/queries.hx
```

#### Push fails for cloud instance
##### Error: Failed to upload to cloud: network timeout
##### Solution:
1. Check internet connection
2. Verify authentication
```bash
helix auth login
```
3. Check cloud service status

#### Instance won't start after `helix push dev` succeeds
##### Error: Instance won't start after `helix push dev` succeeds
##### Solution:
1. Check container status
```bash
docker ps -a | grep helix
```
2. View container logs
```bash
docker logs helix_my-app_dev
```
3. Test connection
```bash
curl http://localhost:6969/health
```
4. Check port binding
```bash
docker port helix_my-app_dev
```

### Migration Issues

#### v1 project detected
##### Error: Found v1 project configuration. Run 'helix migrate' to upgrade to v2.
##### Solution:
Migrate project to v2 format.
```bash
helix migrate --dry-run
helix migrate
```

#### Migration backup failed
##### Error: Failed to create backup directory
##### Solution:
Create backup directory manually
```bash
cp -r . ../project-backup
helix migrate --no-backup
```

### Performance Issues

#### Slow build times
##### Solution:
1. Use release mode for production only
```toml
[local.dev]
build_mode = "dev"  # Faster builds
```
2. Reduce vector config for development
```toml
[local.dev.vector_config]
m = 8
ef_construction = 64
```
3. Clean Docker cache
```bash
docker system prune -a
```

#### High memory usage
##### Solution:
1. Limit database size
```toml
[local.dev.vector_config]
db_max_size_gb = 5
```
2. Adjust Docker resources in Docker Desktop settings as needed.

#### Container crashes
##### Solution:
1. Check logs
```bash
docker logs helix_my-app_dev --tail 100
```
2. Inspect exit code
```bash
docker inspect helix_my-app_dev --format='{{.State.ExitCode}}'
```
3. Increase memory limits
```toml
[local.dev.limits]
max_memory_gb = 8
```

### Network Issues

#### Cannot connect to instance
##### Solution:
1. Check if container is running
```bash
docker ps | grep helix
```
2. Test localhost connection
```bash
telnet localhost 6969
```
3. Check firewall settings
```bash
# macOS
sudo pfctl -s rules

# Linux
sudo iptables -L
```

#### Connection refused
##### Solution:
1. Verify port configuration
```bash
grep port helix.toml
```
2. Check port forwarding
```bash
docker inspect helix_my-app_dev | grep -A 10 "Ports"
```
3. Try different port
```toml
[local.dev]
port = 7070
```

### Common Error Messages

##### Error: "ENOENT: no such file or directory"
##### Solution: 
Missing required files. Run `helix init` to create project structure.

#### "EADDRINUSE: address already in use"
##### Error: "EADDRINUSE: address already in use"
##### Solution: 
Port conflict. Use a different port or stop the conflicting service.

#### "EPERM: operation not permitted"
##### Error: "EPERM: operation not permitted"
##### Solution: 
Permission issue. Check file permissions or run with appropriate privileges.

#### "ECONNREFUSED: Connection refused"
##### Error: "ECONNREFUSED: Connection refused"
##### Solution: 
Service not running. Start the instance with `helix push <instance>`.

#### "ETIMEDOUT: operation timed out"
##### Error: "ETIMEDOUT: operation timed out"
##### Solution: 
Network or performance issue. Check network connection and increase timeouts.

### Debug Mode

Enable debug logging for detailed troubleshooting:
1. Set log level
```bash
export HELIX_LOG_LEVEL=debug
```
2. Run command with debug output
```bash
HELIX_LOG_LEVEL=debug helix push dev
```
3. View detailed Docker logs
```bash
docker logs helix_my-app_dev -f --tail 100
```

### Getting Help

1. [Documentation](https://docs.helix-db.com)
2. [GitHub Issues](https://github.com/HelixDB/helix-db/issues)
3. [Discord](https://discord.gg/2stgMPr5BD)
4. [Email](mailto:founders@helix-db.com)

When reporting issues, include:
- Helix CLI version (`helix --version`)
- Operating system and version
- Docker version (`docker --version`)
- Error messages and logs
- Steps to reproduce
- `helix.toml` (redact secrets)

### Quick Fixes Checklist

Before reporting an issue, try these steps:
1.  Update CLI: `helix update`
2. Validate configuration: `helix check`
3. Restart Docker Desktop
4. Clean up resources: `helix prune`
5. Check disk space: `df -h`
6. Verify network connectivity
7. Review recent changes to `.hx` files
8. Check file permissions
9. Try with a fresh project: `helix init`
10. Enable debug logging: `HELIX_LOG_LEVEL=debug`

# Helix Software Development Kits (SDKs)
@tags: sdk, python, api, client, integration

## Python SDK [helix-py](https://github.com/HelixDB/helix-py) [![PyPI](https://img.shields.io/pypi/v/helix-py.svg)](https://pypi.org/project/helix-py/)
@tags: python, sdk, client, queries, pytorch, llm, provider, embedding, chunking, mcp, model context protocol, pydantic, cloud

### TL;DR
- Install: `uv add helix-py` or `pip install helix-py`
- Connect: `db = helix.Client(local=True)`
- Query: `db.query('add_user', {"name": "John"})`
- Embed: `OpenAIEmbedder().embed("text")`
- Chunk: `Chunk.semantic_chunk(text)`
- LLM Ready: Built-in support for OpenAI, Gemini, and Anthropic providers with MCP tools
- Vector Operations: Native embedding support with OpenAI, Gemini, and VoyageAI embedders
- Text Processing: Integrated chunking with Chonkie for document processing
- Instance Management: Programmatic control over HelixDB instances (start/stop/deploy)
- Type Safe: Pydantic models for structured data and responses
- Local & Cloud: Works with both local Docker instances and cloud deployments

### Installation

```bash
uv add helix-py
# OR
pip install helix-py
```

### Client

Connect to a running helix instance:

```python
import helix

# Connect to a local helix instance
db = helix.Client(local=True, verbose=True)

# Note that the query name is case sensitive (parameters can be empty) -> returns a list of results
db.query('<query_name>', {<query_parameters>})
db.query('add_user', {"name": "John", "age": 20})
```

- Default port: `6969`
- Change port: pass `port` parameter
- Cloud instances: local=False, pass `api_endpoint` parameter, optionally `api_key` parameter

### Custom Queries (not recommended for simple queries)

#### PyTorch-like Query Definition

Given a HelixQL query:
```rust
QUERY add_user(name: String, age: I64) =>
  usr <- AddV<User>({name: name, age: age})
  RETURN usr
```

Define matching Python class:
```python
from helix.client import Query
from helix.types import Payload

class add_user(Query):
    def __init__(self, name: str, age: int):
        super().__init__()
        self.name = name
        self.age = age

    def query(self) -> Payload:
        return [{ "name": self.name, "age": self.age }]

    def response(self, response):
        return response
        
db.query(add_user("John", 20))
```

Requirements
- `Query.query` method must return a list of objects
- Query name is case sensitive

### Instance Management

Setup and manage helix instances programmatically:

```python
from helix.instance import Instance

helix_instance = Instance("helixdb-cfg", 6969, verbose=True)

# Deploy & redeploy instance
helix_instance.deploy()

# Start instance
helix_instance.start()

# Stop instance
helix_instance.stop()

# Delete instance
helix_instance.delete()

# Instance status
print(helix_instance.status())
```

- `helixdb-cfg`: directory for configuration files
- Instance auto-stops on script exit

### LLM Providers

#### Available providers:
- `OpenAIProvider`
- `GeminiProvider`
- `AnthropicProvider`

#### Environment variables required:
- `OPENAI_API_KEY`
- `GEMINI_API_KEY`
- `ANTHROPIC_API_KEY`

#### Provider methods:
- `enable_mcps(name: str, url: str=...) -> bool`
- `generate(messages, response_model: BaseModel | None=None) -> str | BaseModel`

#### Message formats supported:
- Free-form text: string
- Message lists: list of dict or provider-specific `Message` models
- Structured outputs: Pydantic model validation

#### Example usage:
```python
from pydantic import BaseModel
from helix.providers.openai_client import OpenAIProvider

openai_llm = OpenAIProvider(
    name="openai-llm",
    instructions="You are a helpful assistant.",
    model="gpt-5-nano",
    history=True
)

# Free-form text
print(openai_llm.generate("Hello!"))

# Structured output
class Person(BaseModel):
    name: str
    age: int
    occupation: str

print(openai_llm.generate([{"role": "user", "content": "Who am I?"}], Person))
```

#### MCP tools setup:
```python
openai_llm.enable_mcps("helix-mcp")  # default: http://localhost:8000/mcp/
gemini_llm.enable_mcps("helix-mcp", url="https://your-remote-mcp/...")
```

#### Model notes:
- OpenAI GPT-5 family: supports reasoning
- Anthropic: local streamable MCP not supported, use URL-based MCP

### Embedders

#### Available embedders:
- `OpenAIEmbedder`
- `GeminiEmbedder`
- `VoyageAIEmbedder`

#### Embedder interface:
- `embed(text: str, **kwargs) -> [F64]`
- `embed_batch(texts: List[str], **kwargs) -> [[F64]]`

#### Usage examples:
```python
from helix.embedding.openai_client import OpenAIEmbedder
from helix.embedding.gemini_client import GeminiEmbedder
from helix.embedding.voyageai_client import VoyageAIEmbedder

# OpenAI
openai_embedder = OpenAIEmbedder()
vec = openai_embedder.embed("Hello world")
batch = openai_embedder.embed_batch(["a", "b", "c"])

# Gemini
gemini_embedder = GeminiEmbedder()
vec = gemini_embedder.embed("doc text", task_type="RETRIEVAL_DOCUMENT")

# Voyage AI
voyage_embedder = VoyageAIEmbedder()
vec = voyage_embedder.embed("query text", input_type="query")
```

### Chunking

Uses [Chonkie](https://chonkie.ai/) for text processing:

```python
from helix import Chunk

# Basic chunking
text = "Your long document text here..."
chunks = Chunk.token_chunk(text)

# Semantic chunking
semantic_chunks = Chunk.semantic_chunk(text)

# Code chunking
code_text = "def hello(): print('world')"
code_chunks = Chunk.code_chunk(code_text, language="python")

# Batch processing
texts = ["Document 1...", "Document 2...", "Document 3..."]
batch_chunks = Chunk.sentence_chunk(texts)
```

## TypeScript SDK [helix-ts](https://github.com/HelixDB/helix-ts) [![npm](https://img.shields.io/npm/v/helix-ts.svg)](https://www.npmjs.com/package/helix-ts)
@tags: typescript, sdk, client, queries, type-safe, graph, vector, knowledge-graph, search, llm-pipeline

### TL;DR
- Install: `npm install helix-ts`
- Connect: `new HelixDB("http://localhost:6969")`
- Query: `client.query("QueryName", params)`
- Type Safe: Full TypeScript support with schema validation
- Graph & Vector: Native support for both graph and vector operations
- Knowledge Graphs: Built for knowledge graph construction
- LLM Pipelines: Ideal for search systems and LLM integrations
- Async/Await and Batch operations supported

### Installation

```bash
npm install helix-ts
```

### Configuration

#### Basic connection:
```typescript
const client = new HelixDB("http://localhost:6969");
```

#### Cloud endpoint:
```typescript
const client = new HelixDB("https://my-endpoint.com:8080");
```

#### Error handling:
```typescript
client.query("CreateUser", { name: "Alice", age: 25 })
    .then(result => console.log("Created:", result))
    .catch(err => console.error("Query failed:", err));
```

### Quick Start

```typescript
import HelixDB from "helix-ts";

const client = new HelixDB("http://localhost:6969");

// Execute query
const result = await client.query("CreateUser", {
    name: "Alice",
    age: 25,
});
```

### Advanced Usage

#### Async/await pattern:
```typescript
async function createUser(name: string, age: number) {
    try {
        const user = await client.query("CreateUser", { name, age });
        return user;
    } catch (error) {
        console.error("Failed to create user:", error);
        throw error;
    }
}
```

#### Batch operations:
```typescript
const users = [
    { name: "Alice", age: 25 },
    { name: "Bob", age: 30 }
];

const results = await Promise.all(
    users.map(user => client.query("CreateUser", user))
);
```

## Rust SDK [helix-rs](https://github.com/HelixDB/helix-rs) [![crates.io](https://img.shields.io/crates/v/helix-rs.svg)](https://crates.io/crates/helix-rs)
@tags: rust, sdk, client, queries, type-safe, graph, vector, knowledge-graph, search, llm-pipeline, async, serde, tokio

### TL;DR
- Install: `cargo add helix-rs serde tokio`
- Connect: `HelixDB::new(Some("http://localhost"), Some(6969), None)`
- Query: `client.query("QueryName", &payload).await?`
- Type Safe: Full Rust type safety with serde_json
- Async/Await: Built on tokio for async operations
- Graph & Vector: Native support for both graph and vector operations
- Knowledge Graphs: Ideal for knowledge graph construction
- LLM Pipelines: Perfect for search systems and LLM integrations

### Quick Start

```rust
use helix_rs::{HelixDB, HelixDBClient};
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = HelixDB::new(Some("http://localhost"), Some(6969), None);
    
    let result = client.query("CreateUser", &json!({
        "name": "John",
        "age": 20,
    })).await?;
    
    println!("Created user: {result:#?}");
    Ok(())
}
```

### Installation

#### Cargo CLI:
```bash
cargo add helix-rs
cargo add serde
cargo add tokio
```

#### Cargo.toml:
```toml
[dependencies]
helix-rs = "0.1.9"
tokio = { version = "1.47.1", features = ["full"] }
serde = { version = "1.0.219", features = ["derive"] }
```

### Configuration

#### Basic connection:
```rust
let client = HelixDB::new(Some("http://localhost"), Some(6969), None);
```

#### Custom endpoint:
```rust
let client = HelixDB::new(
    Some("https://my-endpoint.com"), 
    Some(8080), 
    Some("my-api-key")
);
```

### Advanced Usage

#### Async patterns:
```rust
#[tokio::main]
async fn create_user(name: &str, age: u8) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
    let client = HelixDB::new(Some("http://localhost"), Some(6969), None);
    
    let payload = json!({
        "name": name,
        "age": age,
    });
    
    client.query("CreateUser", &payload).await
}
```

#### Batch operations:
```rust
let users = vec![
    json!({"name": "Alice", "age": 25}),
    json!({"name": "Bob", "age": 30}),
];

let results: Vec<serde_json::Value> = futures::future::join_all(
    users.into_iter().map(|user| client.query("CreateUser", &user))
).await;
```

## Go SDK [helix-go](https://github.com/HelixDB/helix-go) [![Go Reference](https://pkg.go.dev/badge/github.com/HelixDB/helix-go.svg)](https://pkg.go.dev/github.com/HelixDB/helix-go) 
@tags: go, sdk, client, queries, type-safe, graph, vector, knowledge-graph, search, llm-pipeline, goroutines, context

### TL;DR
- Install: `go get github.com/HelixDB/helix-go`
- Connect: `helix.NewClient("http://localhost:6969")`
- Query: `client.Query("QueryName", helix.WithData(payload)).Scan(&result)`
- Type Safe: Full Go type safety with `map[string]any`
- Goroutines: Built for concurrent operations
- Graph & Vector: Native support for both graph and vector operations
- Knowledge Graphs: Ideal for knowledge graph construction
- LLM Pipelines: Perfect for search systems and LLM integrations

### Installation

```bash
go get github.com/HelixDB/helix-go
```

### Configuration

#### Basic connection:
```go
client := helix.NewClient("http://localhost:6969")
```

#### Custom endpoint:
```go
client := helix.NewClient("https://my-endpoint.com:8080")
```

### Quick Start

```go
package main

import (
    "fmt"
    "log"

    "github.com/HelixDB/helix-go"
)

func main() {
    client := helix.NewClient("http://localhost:6969")
    
    var result map[string]any
    err := client.
        Query("CreateUser", helix.WithData(map[string]any{
            "name": "Alice",
            "age":  uint8(25),
        })).
        Scan(&result)
    
    if err != nil {
        log.Fatalf("Query failed: %s", err)
    }
    
    fmt.Printf("Created user: %#v\n", result)
}
```

### Advanced Usage

#### Error handling:
```go
func createUser(name string, age uint8) (map[string]any, error) {
    client := helix.NewClient("http://localhost:6969")
    
    var result map[string]any
    err := client.
        Query("CreateUser", helix.WithData(map[string]any{
            "name": name,
            "age":  age,
        })).
        Scan(&result)
    
    return result, err
}
```

#### Concurrent operations:
```go
func createUsersConcurrently(users []map[string]any) []map[string]any {
    client := helix.NewClient("http://localhost:6969")
    
    var wg sync.WaitGroup
    results := make([]map[string]any, len(users))
    
    for i, user := range users {
        wg.Add(1)
        go func(index int, data map[string]any) {
            defer wg.Done()
            var result map[string]any
            client.Query("CreateUser", helix.WithData(data)).Scan(&result)
            results[index] = result
        }(i, user)
    }
    
    wg.Wait()
    return results
}
```

# Helix Query Language
@tags: query, language, syntax, cypher, graph, vector, knowledge-graph, search, helixql, query.hx, schema.hx

### TL;DR
- Strongly typed: All queries are type-checked at compile time
- Compiled: Queries are compiled to efficient bytecode for execution
- Graph & Vector: Native support for both graph and vector operations
- Inspired by Gremlin, Cypher and Rust

### Example Query Syntax:

```query.hx
// This is a query for ...
QUERY QueryName(param1: Type, param2: Type) =>
    result <- traversal_expression
    RETURN result
```

### Query Components

- `QUERY`: Keyword to start a query definition
- `QueryName`: Identifier for the query
- `parameters`: Input parameters in parentheses
- `Type`: Type of the parameter (e.g. `String`, `I32`, `F64`, `Boolean`, `[Type]` or schema Node/Edge)
- `=>`: Separates query header from body
- `<-`: Assignment operator
- `RETURN`: Specifies output values
- `//`: Comments

#### Rule
- Query names are case-sensitive. SDK/cURL must match the query name in `query.hx` exactly.

## HelixQL Types
@tags: types, id, date, string, boolean, i8, i16, i32, i64, f32, f64, u8, u16, u32, u64, u128, array

- `ID`: UUID for nodes, edges and vectors
- `Date`: Timestamp or RFC3339 string
- `String`: Text data
- `Boolean`: True/false value
- `I8`: 8-bit signed integer
- `I16`: 16-bit signed integer
- `I32`: 32-bit signed integer
- `I64`: 64-bit signed integer
- `F32`: 32-bit floating point
- `F64`: 64-bit floating point
- `U8`: 8-bit unsigned integer
- `U16`: 16-bit unsigned integer
- `U32`: 32-bit unsigned integer
- `U64`: 64-bit unsigned integer
- `U128`: 128-bit unsigned integer
- `[T]`: Array of any type

## Schema Definition (schema.hx)
@tags: schema, definition, nodes, edges, vectors, indexing, helixql, schema.hx, query.hx

### TL;DR
- Schema defines graph structure: nodes, edges, vectors
- Every entity has implicit `ID` field (not defined in schema)
- Default values supported with `DEFAULT` keyword
- Secondary indexing available for nodes only
- Use `INDEX` keyword for global secondary indexes
- Use `//` for comments

### Node
Defines node types and their properties in the graph.

```schema.hx
N::NodeType {
  field1: String,
  field2: U32
}
```

### Edge
Defines relationships between nodes and their properties.

```schema.hx
E::EdgeType {
  From: Node/Vector,
  To: Node/Vector,
  Properties: {
    field1: String,
    field2: U32
  }
}
```

### Vector
Defines the vector type.

```schema.hx
V::VectorType {
  field1: String
}
```

### Default Values
Set default values for item fields using `DEFAULT` keyword.

```schema.hx
N::NodeType {
  field1: String DEFAULT "default",
  field2: U32 DEFAULT 0
}
```

Helix uses the default value if a value is not provided when inserting the item.

#### Example
The `age` field uses default value `0` when not provided:

```query.hx
QUERY CreateUser(name: String) =>
    user <- AddN<User>({name}) 
    RETURN user
```

### Secondary Indexing
Index node fields as global secondary indexes using `INDEX` keyword.

```schema.hx
N::NodeType {
  INDEX field1: String,
  field2: U32
}
```

This creates an internal table for the indexed field. Query indexed nodes using object syntax:

```query.hx
QUERY GetByIndex(index_field: String) =>
    node <- N<User>({field1: index_field})
    RETURN node
```

Note: Indexing currently only supported for nodes. Indexing for edges and vectors is not supported yet.

## CRUD Operations
@tags: crud, create, read, update, delete, operations, nodes, edges, vectors

### Create

#### Create Nodes using `AddN`

##### Syntax
```query.hx
AddN<Type>
AddN<Type>({properties})
```

##### Example 1: Adding an empty user node

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String,
}
```

- Query:
```query.hx
QUERY CreateUsers () =>
    empty_user <- AddN<User>
    RETURN empty_user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUsers \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client
client = Client(local=True, port=6969)
print(client.query("CreateUsers"))
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const result = await client.query("CreateUsers", {});
    console.log("Created empty user:", result);
}

main().catch((err) => {
    console.error("CreateUsers query failed:", err);
});
```

##### Example 2: Adding a user with parameters

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String,
}
```

- Query:
```query.hx
QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })

    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com"}'
```

- Python SDK:
```python
from helix.client import Client
client = Client(local=True, port=6969)

params = {
    "name": "Alice",
    "age": 25,
    "email": "alice@example.com",
}

print(client.query("CreateUser", params))
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const result = await client.query("CreateUser", {
        name: "Alice",
        age: 25,
        email: "alice@example.com",
    });

    console.log("Created user:", result);
}

main().catch((err) => {
    console.error("CreateUser query failed:", err);
});
```

##### Example 3: Adding a user with predefined properties

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String,
}
```

- Query:
```query.hx
QUERY CreateUser () =>
    predefined_user <- AddN<User>({
        name: "Alice Johnson",
        age: 30,
        email: "alice@example.com"
    })

    RETURN predefined_user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client
client = Client(local=True, port=6969)
print(client.query("CreateUser"))
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const result = await client.query("CreateUser", {});
    console.log("Created predefined user:", result);
}

main().catch((err) => {
    console.error("CreateUser query failed:", err);
});
```

#### Create Edges using `AddE`

##### Syntax
```query.hx
AddE<Type>::From(v1)::To(v2)
AddE<Type>({properties})::From(v1)::To(v2)
```

##### Example 1: Creating a simple follows relationship
- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String,
}

E::Follows {
    From: User,
    To: User,
}
```

- Query:
```query.hx
QUERY CreateRelationships (user1_id: ID, user2_id: ID) =>
    follows <- AddE<Follows>::From(user1_id)::To(user2_id)
    RETURN follows

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":28,"email":"bob@example.com"}'

curl -X POST \
  http://localhost:6969/CreateRelationships \
  -H 'Content-Type: application/json' \
  -d '{"user1_id":"<alice_id>","user2_id":"<bob_id>"}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

alice_id = client.query("CreateUser", {
    "name": "Alice",
    "age": 25,
    "email": "alice@example.com",
})[0]["user"]["id"]

bob_id = client.query("CreateUser", {
    "name": "Bob",
    "age": 28,
    "email": "bob@example.com",
})[0]["user"]["id"]

print(client.query("CreateRelationships", {
    "user1_id": alice_id,
    "user2_id": bob_id,
}))
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const alice = await client.query("CreateUser", {
        name: "Alice",
        age: 25,
        email: "alice@example.com",
    });
    const aliceId: string = alice.user.id;

    const bob = await client.query("CreateUser", {
        name: "Bob",
        age: 28,
        email: "bob@example.com",
    });
    const bobId: string = bob.user.id;

    const follows = await client.query("CreateRelationships", {
        user1_id: aliceId,
        user2_id: bobId,
    });

    console.log("Created follows edge:", follows);
}

main().catch((err) => {
    console.error("CreateRelationships query failed:", err);
});
```

##### Example 2: Creating a detailed friendship with properties

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String,
}

E::Friends {
    From: User,
    To: User,
    Properties: {
        since: Date,
        strength: F64
    }
}
```

- Query:
```query.hx
QUERY CreateFriendship (user1_id: ID, user2_id: ID) =>
    friendship <- AddE<Friends>({
        since: "2024-01-15",
        strength: 0.85
    })::From(user1_id)::To(user2_id)
    RETURN friendship

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie","age":31,"email":"charlie@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Dana","age":29,"email":"dana@example.com"}'

curl -X POST \
  http://localhost:6969/CreateFriendship \
  -H 'Content-Type: application/json' \
  -d '{"user1_id":"<charlie_id>","user2_id":"<dana_id>"}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

user1_id = client.query("CreateUser", {
    "name": "Charlie",
    "age": 31,
    "email": "charlie@example.com",
})[0]["user"]["id"]

user2_id = client.query("CreateUser", {
    "name": "Dana",
    "age": 29,
    "email": "dana@example.com",
})[0]["user"]["id"]

print(client.query("CreateFriendship", {
    "user1_id": user1_id,
    "user2_id": user2_id,
}))
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const charlie = await client.query("CreateUser", {
        name: "Charlie",
        age: 31,
        email: "charlie@example.com",
    });
    const charlieId: string = charlie.user.id;

    const dana = await client.query("CreateUser", {
        name: "Dana",
        age: 29,
        email: "dana@example.com",
    });
    const danaId: string = dana.user.id;

    const friendship = await client.query("CreateFriendship", {
        user1_id: charlieId,
        user2_id: danaId,
    });

    console.log("Created friendship edge:", friendship);
}

main().catch((err) => {
    console.error("CreateFriendship query failed:", err);
});
```

##### Example 3: Traversal Example

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String,
}

E::Follows {
    From: User,
    To: User,
}
```

- Query:
```query.hx
QUERY CreateRelationships (user1_id: ID, user2_name: String) =>
    user2 <- N<User>::WHERE(_::{name}::EQ(user2_name))
    follows <- AddE<Follows>::From(user1_id)::To(user2)
    RETURN follows

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Eve","age":33,"email":"eve@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Frank","age":35,"email":"frank@example.com"}'

curl -X POST \
  http://localhost:6969/CreateRelationships \
  -H 'Content-Type: application/json' \
  -d '{"user1_id":"<eve_id>","user2_name":"Frank"}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

user1 = client.query("CreateUser", {
    "name": "Eve",
    "age": 33,
    "email": "eve@example.com",
})
user1_id = user1[0]["user"]["id"]

client.query("CreateUser", {
    "name": "Frank",
    "age": 35,
    "email": "frank@example.com",
})

print(client.query("CreateRelationships", {
    "user1_id": user1_id,
    "user2_name": "Frank",
}))
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const eve = await client.query("CreateUser", {
        name: "Eve",
        age: 33,
        email: "eve@example.com",
    });
    const eveId: string = eve.user.id;

    await client.query("CreateUser", {
        name: "Frank",
        age: 35,
        email: "frank@example.com",
    });

    const follows = await client.query("CreateRelationships", {
        user1_id: eveId,
        user2_name: "Frank",
    });

    console.log("Created follows edge via traversal:", follows);
}

main().catch((err) => {
    console.error("CreateRelationships traversal failed:", err);
});
```

#### Create Vectors using `AddV`

##### Syntax
```query.hx
AddV<Type>
AddV<Type>(vector, {properties})
```

Note: Currently only supports `[F64]` to represent the vector. Support for `[F32]` and binary vectors added in the future.

##### Example 1: Creating a vector with no properties

- Schema:
```schema.hx
// Uses [F64] by default.
// Properties are optional.
V::Document {}
```

- Query:
```query.hx
QUERY InsertVector (vector: [F64]) =>
    vector_node <- AddV<Document>(vector)
    RETURN vector_node
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/InsertVector \
  -H 'Content-Type: application/json' \
  -d '{"vector":[0.1,0.2,0.3,0.4]}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

print(client.query("InsertVector", {
    "vector": [0.1, 0.2, 0.3, 0.4],
}))
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const result = await client.query("InsertVector", {
        vector: [0.1, 0.2, 0.3, 0.4],
    });

    console.log("Created vector node:", result);
}

main().catch((err) => {
    console.error("InsertVector query failed:", err);
});
```

##### Example 2: Creating a vector with properties

- Schema:
```schema.hx
V::Document {
    content: String,
    created_at: Date
}
```

- Query:
```query.hx
QUERY InsertVector (vector: [F64], content: String, created_at: Date) =>
    vector_node <- AddV<Document>(vector, { content: content, created_at: created_at })
    RETURN vector_node
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/InsertVector \
  -H 'Content-Type: application/json' \
  -d '{"vector":[0.12,0.34,0.56,0.78],"content":"Quick brown fox","created_at":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"}'
```

- Python SDK:
```python
from datetime import datetime, timezone
from helix.client import Client

client = Client(local=True, port=6969)

payload = {
    "vector": [0.12, 0.34, 0.56, 0.78],
    "content": "Quick brown fox",
    "created_at": datetime.now(timezone.utc).isoformat(),
}

print(client.query("InsertVector", payload))
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const result = await client.query("InsertVector", {
        vector: [0.12, 0.34, 0.56, 0.78],
        content: "Quick brown fox",
        created_at: new Date().toISOString(),
    });

    console.log("Created vector node:", result);
}

main().catch((err) => {
    console.error("InsertVector query failed:", err);
});
```

##### Example 3: Creating a vector and connecting it to a node

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String,
}

V::Document {
    content: String,
    created_at: Date
}

E::User_to_Document_Embedding {
    From: User,
    To: Document,
}
```

- Query:
```query.hx
QUERY InsertVector (user_id: ID, vector: [F64], content: String, created_at: Date) =>
    vector_node <- AddV<Document>(vector, { content: content, created_at: created_at })
    edge <- AddE<User_to_Document_Embedding>::From(user_id)::To(vector_node)
    RETURN "Success"

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/InsertVector \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"<user_id>","vector":[0.05,0.25,0.5,0.75],"content":"Favorite quotes","created_at":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"}'
```

- Python SDK:
```python
from datetime import datetime, timezone
from helix.client import Client

client = Client(local=True, port=6969)

user = client.query("CreateUser", {
    "name": "Alice",
    "age": 25,
    "email": "alice@example.com",
})
user_id = user[0]["user"]["id"]

payload = {
    "user_id": user_id,
    "vector": [0.05, 0.25, 0.5, 0.75],
    "content": "Favorite quotes",
    "created_at": datetime.now(timezone.utc).isoformat(),
}

print(client.query("InsertVector", payload))
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const user = await client.query("CreateUser", {
        name: "Alice",
        age: 25,
        email: "alice@example.com",
    });
    const userId: string = user.user.id;

    const result = await client.query("InsertVector", {
        user_id: userId,
        vector: [0.05, 0.25, 0.5, 0.75],
        content: "Favorite quotes",
        created_at: new Date().toISOString(),
    });

    console.log("InsertVector result:", result);
}

main().catch((err) => {
    console.error("InsertVector query failed:", err);
});
```

##### Example 4: Using the built-in [`Embed` function](#embedding-vectors-using-embed)

- Built-in `Embed` function: don't need to send array of floats, just send the text.

- Schema:
```schema.hx
V::Document {
    content: String,
    created_at: Date
}
```

- Query:
```query.hx
QUERY InsertVector (content: String, created_at: Date) =>
    vector_node <- AddV<Document>(Embed(content), { content: content, created_at: created_at })
    RETURN vector_node
```

- Environment variables (OpenAI example):
```.env
OPENAI_API_KEY=your_api_key
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/InsertVector \
  -H 'Content-Type: application/json' \
  -d '{"content":"Quick summary of a meeting","created_at":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"}'
```

- Python SDK:
```python
from datetime import datetime, timezone
from helix.client import Client

client = Client(local=True, port=6969)

payload = {
    "content": "Quick summary of a meeting",
    "created_at": datetime.now(timezone.utc).isoformat(),
}

print(client.query("InsertVector", payload))
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const result = await client.query("InsertVector", {
        content: "Quick summary of a meeting",
        created_at: new Date().toISOString(),
    });

    console.log("InsertVector result:", result);
}

main().catch((err) => {
    console.error("InsertVector query failed:", err);
});
```

### Select

#### Select Nodes using `N`

##### Syntax
```query.hx
N<Type>
N<Type>(node_id)
N<User>({secondary_index: index_field})
```

##### Example 1: Selecting a user by ID

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String,
}
```

- Query:
```query.hx
QUERY GetUser (user_id: ID) =>
    user <- N<User>(user_id)
    RETURN user

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/GetUser \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"<user_id>"}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

user = client.query("CreateUser", {
    "name": "Alice",
    "age": 25,
    "email": "alice@example.com",
})
user_id = user[0]["user"]["id"]

result = client.query("GetUser", {"user_id": user_id})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const created = await client.query("CreateUser", {
        name: "Alice",
        age: 25,
        email: "alice@example.com",
    });
    const userId: string = created.user.id;

    const result = await client.query("GetUser", {
        user_id: userId,
    });

    console.log("GetUser result:", result);
}

main().catch((err) => {
    console.error("GetUser query failed:", err);
});
```

##### Example 2: Selecting all users

Notes:
- You can do [property filtering](#property-access)
- You can do [conditional filtering](#conditional-steps)
- You can do [aggregation](#aggregation)

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String,
}
```

- Query:
```query.hx
QUERY GetAllUsers () =>
    users <- N<User>
    RETURN users
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/GetAllUsers \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

result = client.query("GetAllUsers")
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const result = await client.query("GetAllUsers", {});
    console.log("GetAllUsers result:", result);
}

main().catch((err) => {
    console.error("GetAllUsers query failed:", err);
});
```

#### Select Edges using `E`

##### Syntax
```query.hx
E<Type>
E<Type>(edge_id)
```

##### Example 1: Selecting a follows edge by ID

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String,
}

E::Follows {
    From: User,
    To: User,
}
```

- Query:
```query.hx
QUERY GetFollowEdge (edge_id: ID) =>
    follow_edge <- E<Follows>(edge_id)
    RETURN follow_edge

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user

QUERY CreateRelationships (user1_id: ID, user2_id: ID) =>
    follows <- AddE<Follows>::From(user1_id)::To(user2_id)
    RETURN follows
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":28,"email":"bob@example.com"}'

curl -X POST \
  http://localhost:6969/CreateRelationships \
  -H 'Content-Type: application/json' \
  -d '{"user1_id":"<alice_id>","user2_id":"<bob_id>"}'

curl -X POST \
  http://localhost:6969/GetFollowEdge \
  -H 'Content-Type: application/json' \
  -d '{"edge_id":"<edge_id>"}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

alice = client.query("CreateUser", {
    "name": "Alice",
    "age": 25,
    "email": "alice@example.com",
})
alice_id = alice[0]["user"]["id"]

bob = client.query("CreateUser", {
    "name": "Bob",
    "age": 28,
    "email": "bob@example.com",
})
bob_id = bob[0]["user"]["id"]

follows = client.query("CreateRelationships", {
    "user1_id": alice_id,
    "user2_id": bob_id,
})
edge_id = follows[0]["follows"]["id"]

result = client.query("GetFollowEdge", {"edge_id": edge_id})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const alice = await client.query("CreateUser", {
        name: "Alice",
        age: 25,
        email: "alice@example.com",
    });
    const aliceId: string = alice.user.id;

    const bob = await client.query("CreateUser", {
        name: "Bob",
        age: 28,
        email: "bob@example.com",
    });
    const bobId: string = bob.user.id;

    const follows = await client.query("CreateRelationships", {
        user1_id: aliceId,
        user2_id: bobId,
    });
    const edgeId: string = follows.follows.id;

    const result = await client.query("GetFollowEdge", {
        edge_id: edgeId,
    });

    console.log("GetFollowEdge result:", result);
}

main().catch((err) => {
    console.error("GetFollowEdge query failed:", err);
});
```

##### Example 2: Selecting all follows edges

- Schema:
```schema.hx
E::Follows {
    From: User,
    To: User,
}
```

- Query:
```query.hx
QUERY GetAllFollows () =>
    follows <- E<Follows>
    RETURN follows
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/GetAllFollows \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

result = client.query("GetAllFollows")
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const result = await client.query("GetAllFollows", {});
    console.log("GetAllFollows result:", result);
}

main().catch((err) => {
    console.error("GetAllFollows query failed:", err);
});
```

#### Select Vectors using `V`

##### Syntax
```query.hx
V<Type>
V<Type>(vector_id)
```

##### Example 1: Selecting a vector by ID

- Schema:
```schema.hx
V::Document {
    content: String,
}
```

- Query:
```query.hx
QUERY GetDocumentVector (vector_id: ID) =>
    doc_vector <- V<Document>(vector_id)
    RETURN doc_vector

QUERY CreateDocumentVector (vector: [F64], content: String) =>
    doc_vector <- AddV<Document>(vector, {
        content: content
    })
    RETURN doc_vector
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateDocumentVector \
  -H 'Content-Type: application/json' \
  -d '{"vector":[0.12,0.34,0.56,0.78],"content":"Chunk about vector queries."}'

curl -X POST \
  http://localhost:6969/GetDocumentVector \
  -H 'Content-Type: application/json' \
  -d '{"vector_id":"<vector_id>"}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

vector_payload = [0.12, 0.34, 0.56, 0.78]

created = client.query("CreateDocumentVector", {
    "vector": vector_payload,
    "content": "Chunk about vector queries.",
})
vector_id = created[0]["doc_vector"]["id"]

result = client.query("GetDocumentVector", {"vector_id": vector_id})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const created = await client.query("CreateDocumentVector", {
        vector: [0.12, 0.34, 0.56, 0.78],
        content: "Chunk about vector queries.",
    });
    const vectorId: string = created.doc_vector.id;

    const result = await client.query("GetDocumentVector", {
        vector_id: vectorId,
    });

    console.log("GetDocumentVector result:", result);
}

main().catch((err) => {
    console.error("GetDocumentVector query failed:", err);
});
```

### Update using `UPDATE`

#### Syntax
```query.hx
::UPDATE({<properties_list>})
```

#### Example 1: Updating a person's profile

Note: You only need to include fields you want to change. Any omitted properties stay the same.

- Schema:
```schema.hx
N::Person {
    name: String,
    age: U32,
}
```

- Query:
```query.hx
QUERY UpdateUser(user_id: ID, new_name: String, new_age: U32) =>
    updated <- N<Person>(user_id)::UPDATE({
        name: new_name,
        age: new_age
    })
    RETURN updated

QUERY CreatePerson(name: String, age: U32) =>
    person <- AddN<Person>({
        name: name,
        age: age,
    })
    RETURN person
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreatePerson \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25}'

curl -X POST \
  http://localhost:6969/UpdateUser \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"<person_id>","new_name":"Alice Johnson","new_age":26}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

alice = client.query("CreatePerson", {
    "name": "Alice",
    "age": 25,
})[0]["person"]

updated = client.query("UpdateUser", {
    "user_id": alice["id"],
    "new_name": "Alice Johnson",
    "new_age": 26,
})[0]["updated"]

print("Updated user:", updated)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const createResp = await client.query("CreatePerson", {
        name: "Alice",
        age: 25,
    });

    const updated = await client.query("UpdateUser", {
        user_id: createResp.person.id,
        new_name: "Alice Johnson",
        new_age: 26,
    });

    console.log("Updated user:", updated);
}

main().catch((err) => {
    console.error("UpdateUser failed:", err);
});
```

#### Error Examples: 
- Schema:
```schema.hx
N::Person {
    name: String,
    age: U32,
}
```

- Query:
```query.hx
QUERY UpdateUser(user_id: ID) =>
    // No email field in Person node (invalid field error)
    updatedUsers <- N<Person>(user_id)::UPDATE({ email: "john@example.com" })

    // Age as string instead of U32 (invalid type error)
    updatedUsers <- N<Person>(user_id)::UPDATE({ age: "Hello" })

    RETURN updatedUsers
```

### DELETE using `DROP`

- Drops any traversal that returns elements (nodes, edges, or vectors).
- If empty traversal, it will not drop anything.
- Dropping a node or vector will also drop all its edges.

#### Syntax
```query.hx
DROP <traversal>
```

#### Example 1: Removing a user node by ID

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String,
}

E::Follows {
    From: User,
    To: User,
}
```

- Query:
```query.hx
QUERY DeleteUserNode (user_id: ID) =>
    DROP N<User>(user_id)
    RETURN "Removed user node"

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({ name: name, age: age, email: email })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Yara","age":24,"email":"yara@example.com"}'
curl -X POST \
  http://localhost:6969/DeleteUserNode \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"<yara_id>"}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

yara = client.query("CreateUser", {
    "name": "Yara",
    "age": 24,
    "email": "yara@example.com",
})
yara_id = yara[0]["user"]["id"]

result = client.query("DeleteUserNode", {"user_id": yara_id})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const yara = await client.query("CreateUser", {
        name: "Yara",
        age: 24,
        email: "yara@example.com",
    });
    const yaraId: string = yara.user.id;

    const result = await client.query("DeleteUserNode", {
        user_id: yaraId,
    });

    console.log("DeleteUserNode result:", result);
}

main().catch((err) => {
    console.error("DeleteUserNode query failed:", err);
});
```

#### Example 2: Removing outgoing neighbors

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String,
}

E::Follows {
    From: User,
    To: User,
}
```

- Query:
```query.hx
QUERY DeleteOutgoingNeighbors (user_id: ID) =>
    DROP N<User>(user_id)::Out<Follows>
    RETURN "Removed outgoing neighbors"

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({ name: name, age: age, email: email })
    RETURN user

QUERY CreateRelationships (user1_id: ID, user2_id: ID) =>
    follows <- AddE<Follows>::From(user1_id)::To(user2_id)
    RETURN follows
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Lena","age":30,"email":"lena@example.com"}'
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Mason","age":29,"email":"mason@example.com"}'
curl -X POST \
  http://localhost:6969/CreateRelationships \
  -H 'Content-Type: application/json' \
  -d '{"user1_id":"<lena_id>","user2_id":"<mason_id>"}'

curl -X POST \
  http://localhost:6969/DeleteOutgoingNeighbors \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"<lena_id>"}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

lena = client.query("CreateUser", {
    "name": "Lena",
    "age": 30,
    "email": "lena@example.com",
})
lena_id = lena[0]["user"]["id"]

mason = client.query("CreateUser", {
    "name": "Mason",
    "age": 29,
    "email": "mason@example.com",
})
mason_id = mason[0]["user"]["id"]

client.query("CreateRelationships", {
    "user1_id": lena_id,
    "user2_id": mason_id,
})

result = client.query("DeleteOutgoingNeighbors", {"user_id": lena_id})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const lena = await client.query("CreateUser", {
        name: "Lena",
        age: 30,
        email: "lena@example.com",
    });
    const lenaId: string = lena.user.id;

    const mason = await client.query("CreateUser", {
        name: "Mason",
        age: 29,
        email: "mason@example.com",
    });
    const masonId: string = mason.user.id;

    await client.query("CreateRelationships", {
        user1_id: lenaId,
        user2_id: masonId,
    });

    const result = await client.query("DeleteOutgoingNeighbors", {
        user_id: lenaId,
    });

    console.log("DeleteOutgoingNeighbors result:", result);
}

main().catch((err) => {
    console.error("DeleteOutgoingNeighbors query failed:", err);
});
```

#### Example 3: Removing incoming neighbors

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String,
}

E::Follows {
    From: User,
    To: User,
}
```

- Query:
```query.hx
QUERY DeleteIncomingNeighbors (user_id: ID) =>
    DROP N<User>(user_id)::In<Follows>
    RETURN "Removed incoming neighbors"

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({ name: name, age: age, email: email })
    RETURN user

QUERY CreateRelationships (user1_id: ID, user2_id: ID) =>
    follows <- AddE<Follows>::From(user1_id)::To(user2_id)
    RETURN follows
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Ophelia","age":32,"email":"ophelia@example.com"}'
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Paul","age":31,"email":"paul@example.com"}'
curl -X POST \
  http://localhost:6969/CreateRelationships \
  -H 'Content-Type: application/json' \
  -d '{"user1_id":"<paul_id>","user2_id":"<ophelia_id>"}'

curl -X POST \
  http://localhost:6969/DeleteIncomingNeighbors \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"<ophelia_id>"}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

ophelia = client.query("CreateUser", {
    "name": "Ophelia",
    "age": 32,
    "email": "ophelia@example.com",
})
ophelia_id = ophelia[0]["user"]["id"]

paul = client.query("CreateUser", {
    "name": "Paul",
    "age": 31,
    "email": "paul@example.com",
})
paul_id = paul[0]["user"]["id"]

client.query("CreateRelationships", {
    "user1_id": paul_id,
    "user2_id": ophelia_id,
})

result = client.query("DeleteIncomingNeighbors", {"user_id": ophelia_id})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const ophelia = await client.query("CreateUser", {
        name: "Ophelia",
        age: 32,
        email: "ophelia@example.com",
    });
    const opheliaId: string = ophelia.user.id;

    const paul = await client.query("CreateUser", {
        name: "Paul",
        age: 31,
        email: "paul@example.com",
    });
    const paulId: string = paul.user.id;

    await client.query("CreateRelationships", {
        user1_id: paulId,
        user2_id: opheliaId,
    });

    const result = await client.query("DeleteIncomingNeighbors", {
        user_id: opheliaId,
    });

    console.log("DeleteIncomingNeighbors result:", result);
}

main().catch((err) => {
    console.error("DeleteIncomingNeighbors query failed:", err);
});
```

#### Example 4: Removing outgoing edges only

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String,
}

E::Follows {
    From: User,
    To: User,
}
```

- Query:
```query.hx
QUERY DeleteOutgoingEdges (user_id: ID) =>
    DROP N<User>(user_id)::OutE<Follows>
    RETURN "Removed outgoing edges"

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({ name: name, age: age, email: email })
    RETURN user

QUERY CreateRelationships (user1_id: ID, user2_id: ID) =>
    follows <- AddE<Follows>::From(user1_id)::To(user2_id)
    RETURN follows
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Riley","age":26,"email":"riley@example.com"}'
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Sam","age":25,"email":"sam@example.com"}'
curl -X POST \
  http://localhost:6969/CreateRelationships \
  -H 'Content-Type: application/json' \
  -d '{"user1_id":"<riley_id>","user2_id":"<sam_id>"}'

curl -X POST \
  http://localhost:6969/DeleteOutgoingEdges \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"<riley_id>"}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

riley = client.query("CreateUser", {
    "name": "Riley",
    "age": 26,
    "email": "riley@example.com",
})
riley_id = riley[0]["user"]["id"]

sam = client.query("CreateUser", {
    "name": "Sam",
    "age": 25,
    "email": "sam@example.com",
})
sam_id = sam[0]["user"]["id"]

client.query("CreateRelationships", {
    "user1_id": riley_id,
    "user2_id": sam_id,
})

result = client.query("DeleteOutgoingEdges", {"user_id": riley_id})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const riley = await client.query("CreateUser", {
        name: "Riley",
        age: 26,
        email: "riley@example.com",
    });
    const rileyId: string = riley.user.id;

    const sam = await client.query("CreateUser", {
        name: "Sam",
        age: 25,
        email: "sam@example.com",
    });
    const samId: string = sam.user.id;

    await client.query("CreateRelationships", {
        user1_id: rileyId,
        user2_id: samId,
    });

    const result = await client.query("DeleteOutgoingEdges", {
        user_id: rileyId,
    });

    console.log("DeleteOutgoingEdges result:", result);
}

main().catch((err) => {
    console.error("DeleteOutgoingEdges query failed:", err);
});
```

#### Example 5: Removing incoming edges only

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String,
}

E::Follows {
    From: User,
    To: User,
}
```

- Query:
```query.hx
QUERY DeleteIncomingEdges (user_id: ID) =>
    DROP N<User>(user_id)::InE<Follows>
    RETURN "Removed incoming edges"

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({ name: name, age: age, email: email })
    RETURN user

QUERY CreateRelationships (user1_id: ID, user2_id: ID) =>
    follows <- AddE<Follows>::From(user1_id)::To(user2_id)
    RETURN follows
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Uma","age":28,"email":"uma@example.com"}'
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Vince","age":29,"email":"vince@example.com"}'
curl -X POST \
  http://localhost:6969/CreateRelationships \
  -H 'Content-Type: application/json' \
  -d '{"user1_id":"<vince_id>","user2_id":"<uma_id>"}'

curl -X POST \
  http://localhost:6969/DeleteIncomingEdges \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"<uma_id>"}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

uma = client.query("CreateUser", {
    "name": "Uma",
    "age": 28,
    "email": "uma@example.com",
})
uma_id = uma[0]["user"]["id"]

vince = client.query("CreateUser", {
    "name": "Vince",
    "age": 29,
    "email": "vince@example.com",
})
vince_id = vince[0]["user"]["id"]

client.query("CreateRelationships", {
    "user1_id": vince_id,
    "user2_id": uma_id,
})

result = client.query("DeleteIncomingEdges", {"user_id": uma_id})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const uma = await client.query("CreateUser", {
        name: "Uma",
        age: 28,
        email: "uma@example.com",
    });
    const umaId: string = uma.user.id;

    const vince = await client.query("CreateUser", {
        name: "Vince",
        age: 29,
        email: "vince@example.com",
    });
    const vinceId: string = vince.user.id;

    await client.query("CreateRelationships", {
        user1_id: vinceId,
        user2_id: umaId,
    });

    const result = await client.query("DeleteIncomingEdges", {
        user_id: umaId,
    });

    console.log("DeleteIncomingEdges result:", result);
}

main().catch((err) => {
    console.error("DeleteIncomingEdges query failed:", err);
});
```

## Graph Traversals
@tags: traversal, graph, navigation, out, in, outE, inE, fromN, toN, fromV, toV, relationships

### Traversal From Nodes and Vectors

Note:
- Combine traversals with [property access](#property-access) or [aggregation](#aggregation) for richer results

#### Traverse Out to Nodes and Vectors using `Out`

##### Syntax
```query.hx
::Out<EdgeType>
```

##### Example 1: Listing who a user follows

- Schema:
```schema.hx
N::User {
    name: String,
    handle: String,
}

E::Follows {
    From: User,
    To: User,
    Properties: {
        since: Date
    }
}
```

- Query:
```query.hx
QUERY GetUserFollowing (user_id: ID) =>
    following <- N<User>(user_id)::Out<Follows>
    RETURN following

QUERY CreateUser (name: String, handle: String) =>
    user <- AddN<User>({
        name: name,
        handle: handle,
    })
    RETURN user

QUERY FollowUser (follower_id: ID, followed_id: ID, since: Date) =>
    follow_edge <- AddE<Follows>({
        since: since
    })::From(follower_id)::To(followed_id)
    RETURN follow_edge
```

- cURL:
```bash
alice=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","handle":"alice"}')
alice_id=$(echo "$alice" | jq -r '.user.id')

bob=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","handle":"bobby"}')
bob_id=$(echo "$bob" | jq -r '.user.id')

since=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

curl -X POST \
  http://localhost:6969/FollowUser \
  -H 'Content-Type: application/json' \
  -d '{"follower_id":"'"$alice_id"'","followed_id":"'"$bob_id"'","since":"'"$since"'"}'

curl -X POST \
  http://localhost:6969/GetUserFollowing \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"'"$alice_id"'"}'
```

- Python SDK:
```python
from helix.client import Client
from datetime import datetime, timezone

client = Client(local=True, port=6969)
since_value = datetime.now(timezone.utc).isoformat()

alice = client.query("CreateUser", {"name": "Alice", "handle": "alice"})
bob = client.query("CreateUser", {"name": "Bob", "handle": "bobby"})

alice_id = alice[0]["user"]["id"]
bob_id = bob[0]["user"]["id"]

client.query("FollowUser", {
    "follower_id": alice_id,
    "followed_id": bob_id,
    "since": since_value,
})

result = client.query("GetUserFollowing", {"user_id": alice_id})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");
    const sinceValue = new Date().toISOString();

    const alice = await client.query("CreateUser", {
        name: "Alice",
        handle: "alice",
    });
    const bob = await client.query("CreateUser", {
        name: "Bob",
        handle: "bobby",
    });

    await client.query("FollowUser", {
        follower_id: alice.user.id,
        followed_id: bob.user.id,
        since: sinceValue,
    });

    const result = await client.query("GetUserFollowing", {
        user_id: alice.user.id,
    });

    console.log("GetUserFollowing result:", result);
}

main().catch((err) => {
    console.error("GetUserFollowing query failed:", err);
});
```

#### Traverse In to Nodes and Vectors using `In`

##### Syntax
```query.hx
::In<EdgeType>
```

##### Example 1: Listing who follows a user

- Schema:
```schema.hx
N::User {
    name: String,
    handle: String,
}

E::Follows {
    From: User,
    To: User,
    Properties: {
        since: Date
    }
}
```

- Query:
```query.hx
QUERY GetUserFollowers (user_id: ID) =>
    followers <- N<User>(user_id)::In<Follows>
    RETURN followers

QUERY CreateUser (name: String, handle: String) =>
    user <- AddN<User>({
        name: name,
        handle: handle,
    })
    RETURN user

QUERY FollowUser (follower_id: ID, followed_id: ID, since: Date) =>
    follow_edge <- AddE<Follows>({
        since: since
    })::From(follower_id)::To(followed_id)
    RETURN follow_edge
```

- cURL:
```bash
alice=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","handle":"alice"}')
alice_id=$(echo "$alice" | jq -r '.user.id')

bob=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","handle":"bobby"}')
bob_id=$(echo "$bob" | jq -r '.user.id')

since=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

curl -X POST \
  http://localhost:6969/FollowUser \
  -H 'Content-Type: application/json' \
  -d '{"follower_id":"'"$alice_id"'","followed_id":"'"$bob_id"'","since":"'"$since"'"}'

curl -X POST \
  http://localhost:6969/GetUserFollowers \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"'"$bob_id"'"}'
```

- Python SDK:
```python
from helix.client import Client
from datetime import datetime, timezone

client = Client(local=True, port=6969)
since_value = datetime.now(timezone.utc).isoformat()

alice = client.query("CreateUser", {"name": "Alice", "handle": "alice"})
bob = client.query("CreateUser", {"name": "Bob", "handle": "bobby"})

alice_id = alice[0]["user"]["id"]
bob_id = bob[0]["user"]["id"]

client.query("FollowUser", {
    "follower_id": alice_id,
    "followed_id": bob_id,
    "since": since_value,
})

result = client.query("GetUserFollowers", {"user_id": bob_id})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");
    const sinceValue = new Date().toISOString();

    const alice = await client.query("CreateUser", {
        name: "Alice",
        handle: "alice",
    });
    const bob = await client.query("CreateUser", {
        name: "Bob",
        handle: "bobby",
    });

    await client.query("FollowUser", {
        follower_id: alice.user.id,
        followed_id: bob.user.id,
        since: sinceValue,
    });

    const result = await client.query("GetUserFollowers", {
        user_id: bob.user.id,
    });

    console.log("GetUserFollowers result:", result);
}

main().catch((err) => {
    console.error("GetUserFollowers query failed:", err);
});
```

#### Traverse Out to Edges using `OutE`

##### Syntax
```query.hx
::OutE<EdgeType>
```

##### Example 1: Inspecting follow relationships

- Schema:
```schema.hx
N::User {
    name: String,
    handle: String,
}

E::Follows {
    From: User,
    To: User,
    Properties: {
        since: Date
    }
}
```

- Query:
```query.hx
QUERY GetFollowingEdges (user_id: ID) =>
    follow_edges <- N<User>(user_id)::OutE<Follows>
    RETURN follow_edges

QUERY CreateUser (name: String, handle: String) =>
    user <- AddN<User>({
        name: name,
        handle: handle,
    })
    RETURN user

QUERY FollowUser (follower_id: ID, followed_id: ID, since: Date) =>
    follow_edge <- AddE<Follows>({
        since: since
    })::From(follower_id)::To(followed_id)
    RETURN follow_edge
```

- cURL:
```bash
alice=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","handle":"alice"}')
alice_id=$(echo "$alice" | jq -r '.user.id')

bob=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","handle":"bobby"}')
bob_id=$(echo "$bob" | jq -r '.user.id')

since=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

curl -X POST \
  http://localhost:6969/FollowUser \
  -H 'Content-Type: application/json' \
  -d '{"follower_id":"'"$alice_id"'","followed_id":"'"$bob_id"'","since":"'"$since"'"}'

curl -X POST \
  http://localhost:6969/GetFollowingEdges \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"'"$alice_id"'"}'
```

- Python SDK:
```python
from helix.client import Client
from datetime import datetime, timezone

client = Client(local=True, port=6969)
since_value = datetime.now(timezone.utc).isoformat()

alice = client.query("CreateUser", {"name": "Alice", "handle": "alice"})
bob = client.query("CreateUser", {"name": "Bob", "handle": "bobby"})

alice_id = alice[0]["user"]["id"]
bob_id = bob[0]["user"]["id"]

client.query("FollowUser", {
    "follower_id": alice_id,
    "followed_id": bob_id,
    "since": since_value,
})

edges = client.query("GetFollowingEdges", {"user_id": alice_id})
print(edges)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");
    const sinceValue = new Date().toISOString();

    const alice = await client.query("CreateUser", {
        name: "Alice",
        handle: "alice",
    });
    const bob = await client.query("CreateUser", {
        name: "Bob",
        handle: "bobby",
    });

    await client.query("FollowUser", {
        follower_id: alice.user.id,
        followed_id: bob.user.id,
        since: sinceValue,
    });

    const edges = await client.query("GetFollowingEdges", {
        user_id: alice.user.id,
    });

    console.log("GetFollowingEdges result:", edges);
}

main().catch((err) => {
    console.error("GetFollowingEdges query failed:", err);
});
```

#### Traverse In to Edges using `InE`

##### Syntax
```query.hx
::InE<EdgeType>
```

##### Example 1: Inspecting who followed a user

- Schema:
```schema.hx
N::User {
    name: String,
    handle: String,
}

E::Follows {
    From: User,
    To: User,
    Properties: {
        since: Date
    }
}
```

- Query:
```query.hx
QUERY GetFollowerEdges (user_id: ID) =>
    follow_edges <- N<User>(user_id)::InE<Follows>
    RETURN follow_edges

QUERY CreateUser (name: String, handle: String) =>
    user <- AddN<User>({
        name: name,
        handle: handle,
    })
    RETURN user

QUERY FollowUser (follower_id: ID, followed_id: ID, since: Date) =>
    follow_edge <- AddE<Follows>({
        since: since
    })::From(follower_id)::To(followed_id)
    RETURN follow_edge
```

- cURL:
```bash
alice=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","handle":"alice"}')
alice_id=$(echo "$alice" | jq -r '.user.id')

bob=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","handle":"bobby"}')
bob_id=$(echo "$bob" | jq -r '.user.id')

since=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

curl -X POST \
  http://localhost:6969/FollowUser \
  -H 'Content-Type: application/json' \
  -d '{"follower_id":"'"$alice_id"'","followed_id":"'"$bob_id"'","since":"'"$since"'"}'

curl -X POST \
  http://localhost:6969/GetFollowerEdges \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"'"$bob_id"'"}'
```

- Python SDK:
```python
from helix.client import Client
from datetime import datetime, timezone

client = Client(local=True, port=6969)
since_value = datetime.now(timezone.utc).isoformat()

alice = client.query("CreateUser", {"name": "Alice", "handle": "alice"})
bob = client.query("CreateUser", {"name": "Bob", "handle": "bobby"})

alice_id = alice[0]["user"]["id"]
bob_id = bob[0]["user"]["id"]

client.query("FollowUser", {
    "follower_id": alice_id,
    "followed_id": bob_id,
    "since": since_value,
})

edges = client.query("GetFollowerEdges", {"user_id": bob_id})
print(edges)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");
    const sinceValue = new Date().toISOString();

    const alice = await client.query("CreateUser", {
        name: "Alice",
        handle: "alice",
    });
    const bob = await client.query("CreateUser", {
        name: "Bob",
        handle: "bobby",
    });

    await client.query("FollowUser", {
        follower_id: alice.user.id,
        followed_id: bob.user.id,
        since: sinceValue,
    });

    const edges = await client.query("GetFollowerEdges", {
        user_id: bob.user.id,
    });

    console.log("GetFollowerEdges result:", edges);
}

main().catch((err) => {
    console.error("GetFollowerEdges query failed:", err);
});
```

### Traversal From Edges

#### Traverse to Source Node using `FromN`

##### Syntax
```query.hx
::FromN
```

##### Example 1: Getting the user from a document creation edge

- Schema:
```schema.hx
N::User {
    name: String,
    email: String,
}

V::Document {
    content: String
}

E::Creates {
    From: User,
    To: Document
}
```

- Query:
```query.hx
QUERY GetCreatorFromEdge (creation_id: ID) =>
    creator <- E<Creates>(creation_id)::FromN
    RETURN creator

QUERY CreateUser (name: String, email: String) =>
    user <- AddN<User>({
        name: name,
        email: email,
    })
    RETURN user

QUERY CreateDocument (user_id: ID, content: String, vector: [F64]) =>
    document <- AddV<Document>(vector, {
        content: content
    })
    creation_edge <- AddE<Creates>::From(user_id)::To(document)
    RETURN creation_edge
```

- cURL:
```bash
alice=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","email":"alice@example.com"}')
alice_id=$(echo "$alice" | jq -r '.user.id')

creation=$(curl -s -X POST \
  http://localhost:6969/CreateDocument \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"'"$alice_id"'","content":"This is my first document","vector":[0.1,0.2,0.3,0.4,0.5]}')
creation_id=$(echo "$creation" | jq -r '.creation_edge.id')

curl -s -X POST \
  http://localhost:6969/GetCreatorFromEdge \
  -H 'Content-Type: application/json' \
  -d '{"creation_id":"'"$creation_id"'"}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

alice = client.query("CreateUser", {"name": "Alice", "email": "alice@example.com"})
alice_id = alice[0]["user"]["id"]

creation = client.query("CreateDocument", {
    "user_id": alice_id,
    "content": "This is my first document",
    "vector": [0.1, 0.2, 0.3, 0.4, 0.5],
})
creation_id = creation[0]["creation_edge"]["id"]

result = client.query("GetCreatorFromEdge", {
    "creation_id": creation_id,
})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const alice = await client.query("CreateUser", {
        name: "Alice",
        email: "alice@example.com",
    });

    const creation = await client.query("CreateDocument", {
        user_id: alice.user.id,
        content: "This is my first document",
        vector: [0.1, 0.2, 0.3, 0.4, 0.5],
    });

    const result = await client.query("GetCreatorFromEdge", {
        creation_id: creation.creation_edge.id,
    });

    console.log("GetCreatorFromEdge result:", result);
}

main().catch((err) => {
    console.error("GetCreatorFromEdge query failed:", err);
});
```

#### Traverse to Source Vector using `FromV`

##### Syntax
```query.hx
::FromV
```

#####  Example 1: Inspecting the document vector from edge

- Schema:
```schema.hx
N::User {
    name: String,
    email: String,
}

V::Document {
    content: String
}

E::Creates {
    From: User,
    To: Document
}
```

- Query:
```query.hx
QUERY GetDocumentVector (creation_id: ID) =>
    document_vector <- E<Creates>(creation_id)::ToV
    RETURN document_vector

QUERY CreateUser (name: String, email: String) =>
    user <- AddN<User>({
        name: name,
        email: email,
    })
    RETURN user

QUERY CreateDocument (user_id: ID, content: String, vector: [F64]) =>
    document <- AddV<Document>(vector, {
        content: content
    })
    creation_edge <- AddE<Creates>::From(user_id)::To(document)
    RETURN creation_edge
```

- cURL:
```bash
alice=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","email":"alice@example.com"}')
alice_id=$(echo "$alice" | jq -r '.user.id')

creation=$(curl -s -X POST \
  http://localhost:6969/CreateDocument \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"'"$alice_id"'","content":"This is my first document","vector":[0.1,0.2,0.3,0.4,0.5]}')
creation_id=$(echo "$creation" | jq -r '.creation_edge.id')

curl -s -X POST \
  http://localhost:6969/GetDocumentVector \
  -H 'Content-Type: application/json' \
  -d '{"creation_id":"'"$creation_id"'"}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

alice = client.query("CreateUser", {"name": "Alice", "email": "alice@example.com"})
alice_id = alice[0]["user"]["id"]

creation = client.query("CreateDocument", {
    "user_id": alice_id,
    "content": "This is my first document",
    "vector": [0.1, 0.2, 0.3, 0.4, 0.5],
})
creation_id = creation[0]["creation_edge"]["id"]

vector = client.query("GetDocumentVector", {
    "creation_id": creation_id,
})
print(vector)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const alice = await client.query("CreateUser", {
        name: "Alice",
        email: "alice@example.com",
    });

    const creation = await client.query("CreateDocument", {
        user_id: alice.user.id,
        content: "This is my first document",
        vector: [0.1, 0.2, 0.3, 0.4, 0.5],
    });

    const vector = await client.query("GetDocumentVector", {
        creation_id: creation.creation_edge.id,
    });

    console.log("GetDocumentVector result:", vector);
}

main().catch((err) => {
    console.error("GetDocumentVector query failed:", err);
});
```

#### Traverse to Target Node using `ToN`

##### Syntax
```query.hx
::ToN
```

##### Example 1: Getting the followed user from a follow edge

- Schema:
```schema.hx
N::User {
    name: String,
    email: String,
}

E::Follows {
    From: User,
    To: User
}
```

- Query:
```query.hx
QUERY GetFollowedUser (follow_id: ID) =>
    followed_user <- E<Follows>(follow_id)::ToN
    RETURN followed_user

QUERY CreateUser (name: String, email: String) =>
    user <- AddN<User>({
        name: name,
        email: email,
    })
    RETURN user

QUERY FollowUser (follower_id: ID, followed_id: ID, since: String) =>
    follow_edge <- AddE<Follows>::From(follower_id)::To(followed_id)
    RETURN follow_edge
```

- cURL:
```bash
alice=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","email":"alice@example.com"}')
alice_id=$(echo "$alice" | jq -r '.user.id')

bob=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","email":"bob@example.com"}')
bob_id=$(echo "$bob" | jq -r '.user.id')

since=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

follow=$(curl -s -X POST \
  http://localhost:6969/FollowUser \
  -H 'Content-Type: application/json' \
  -d '{"follower_id":"'"$alice_id"'","followed_id":"'"$bob_id"'","since":"'"$since"'"}')
follow_id=$(echo "$follow" | jq -r '.follow_edge.id')

curl -s -X POST \
  http://localhost:6969/GetFollowedUser \
  -H 'Content-Type: application/json' \
  -d '{"follow_id":"'"$follow_id"'"}'
```

- Python SDK:
```python
from helix.client import Client
from datetime import datetime

client = Client(local=True, port=6969)

alice = client.query("CreateUser", {"name": "Alice", "email": "alice@example.com"})
alice_id = alice[0]["user"]["id"]

bob = client.query("CreateUser", {"name": "Bob", "email": "bob@example.com"})
bob_id = bob[0]["user"]["id"]

since_value = datetime.now().isoformat()

follow = client.query("FollowUser", {
    "follower_id": alice_id,
    "followed_id": bob_id,
    "since": since_value,
})
follow_id = follow[0]["follow_edge"]["id"]

followed_user = client.query("GetFollowedUser", {
    "follow_id": follow_id,
})
print(followed_user)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");
    const sinceValue = new Date().toISOString();

    const alice = await client.query("CreateUser", {
        name: "Alice",
        email: "alice@example.com",
    });

    const bob = await client.query("CreateUser", {
        name: "Bob",
        email: "bob@example.com",
    });

    const follow = await client.query("FollowUser", {
        follower_id: alice.user.id,
        followed_id: bob.user.id,
        since: sinceValue,
    });

    const followedUser = await client.query("GetFollowedUser", {
        follow_id: follow.follow_edge.id,
    });

    console.log("GetFollowedUser result:", followedUser);
}

main().catch((err) => {
    console.error("GetFollowedUser query failed:", err);
});
```

#### Traverse to Target Vector using `ToV`

##### Syntax
```query.hx
::ToV
```

##### Example 1: Inspecting the document vector

- Schema:
```schema.hx
N::User {
    name: String,
    email: String,
}

V::Document {
    content: String
}

E::Creates {
    From: User,
    To: Document
}
```

- Query:
```query.hx
QUERY GetDocumentVector (creation_id: ID) =>
    document_vector <- E<Creates>(creation_id)::ToV
    RETURN document_vector

QUERY CreateUser (name: String, email: String) =>
    user <- AddN<User>({
        name: name,
        email: email,
    })
    RETURN user

QUERY CreateDocument (user_id: ID, content: String, vector: [F64]) =>
    document <- AddV<Document>(vector, {
        content: content
    })
    creation_edge <- AddE<Creates>::From(user_id)::To(document)
    RETURN creation_edge
```

- cURL:
```bash
alice=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","email":"alice@example.com"}')
alice_id=$(echo "$alice" | jq -r '.user.id')

creation=$(curl -s -X POST \
  http://localhost:6969/CreateDocument \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"'"$alice_id"'","content":"This is my first document","vector":[0.1,0.2,0.3,0.4,0.5]}')
creation_id=$(echo "$creation" | jq -r '.creation_edge.id')

curl -s -X POST \
  http://localhost:6969/GetDocumentVector \
  -H 'Content-Type: application/json' \
  -d '{"creation_id":"'"$creation_id"'"}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

alice = client.query("CreateUser", {"name": "Alice", "email": "alice@example.com"})
alice_id = alice[0]["user"]["id"]

creation = client.query("CreateDocument", {
    "user_id": alice_id,
    "content": "This is my first document",
    "vector": [0.1, 0.2, 0.3, 0.4, 0.5],
})
creation_id = creation[0]["creation_edge"]["id"]

vector = client.query("GetDocumentVector", {
    "creation_id": creation_id,
})
print(vector)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const alice = await client.query("CreateUser", {
        name: "Alice",
        email: "alice@example.com",
    });

    const creation = await client.query("CreateDocument", {
        user_id: alice.user.id,
        content: "This is my first document",
        vector: [0.1, 0.2, 0.3, 0.4, 0.5],
    });

    const vector = await client.query("GetDocumentVector", {
        creation_id: creation.creation_edge.id,
    });

    console.log("GetDocumentVector result:", vector);
}

main().catch((err) => {
    console.error("GetDocumentVector query failed:", err);
});
```

## Result Operations
@tags: results, count, limit, skip, sort, order, pagination, filtering

### Count Elements using `COUNT`

#### Syntax
```query.hx
::COUNT
```

#### Example 1: Basic element counting

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY GetUserCount () =>
    user_count <- N<User>::COUNT
    RETURN user_count

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":30,"email":"bob@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie","age":28,"email":"charlie@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Diana","age":22,"email":"diana@example.com"}'

curl -X POST \
  http://localhost:6969/GetUserCount \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {"name": "Alice", "age": 25, "email": "alice@example.com"},
    {"name": "Bob", "age": 30, "email": "bob@example.com"},
    {"name": "Charlie", "age": 28, "email": "charlie@example.com"},
    {"name": "Diana", "age": 22, "email": "diana@example.com"},
]

for user in users:
    client.query("CreateUser", user)

result = client.query("GetUserCount", {})
print(f"Total users: {result}")
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        { name: "Alice", age: 25, email: "alice@example.com" },
        { name: "Bob", age: 30, email: "bob@example.com" },
        { name: "Charlie", age: 28, email: "charlie@example.com" },
        { name: "Diana", age: 22, email: "diana@example.com" },
    ];

    for (const user of users) {
        await client.query("CreateUser", user);
    }

    const result = await client.query("GetUserCount", {});
    console.log("Total users:", result);
}

main().catch((err) => {
    console.error("GetUserCount query failed:", err);
});
```

### Scope Results using `RANGE`

#### Syntax
```query.hx
::RANGE(start, end)
```

Notes:
- Both `start` and `end` are required and must be positive integers (I64).
- `RANGE` is 0-based, so the first element is 0, the second element is 1, etc.
- `RANGE` is inclusing of `start` but exclusive of `end`. So `RANGE(0, 10)` will return elements 0 to 9 (10 elements).

#### Example 1: Basic pagination

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY GetUsersPaginated (start: U32, end: U32) =>
    users <- N<User>::RANGE(start, end)
    RETURN users

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"User0","age":20,"email":"user0@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"User1","age":21,"email":"user1@example.com"}'

curl -X POST \
  http://localhost:6969/GetUsersPaginated \
  -H 'Content-Type: application/json' \
  -d '{"start":0,"end":5}'

curl -X POST \
  http://localhost:6969/GetUsersPaginated \
  -H 'Content-Type: application/json' \
  -d '{"start":5,"end":10}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

for i in range(20):
    client.query("CreateUser", {
        "name": f"User{i}",
        "age": 20 + (i % 40),
        "email": f"user{i}@example.com"
    })

page1 = client.query("GetUsersPaginated", {"start": 0, "end": 5})
print("Page 1:", page1)

page2 = client.query("GetUsersPaginated", {"start": 5, "end": 10})
print("Page 2:", page2)

page3 = client.query("GetUsersPaginated", {"start": 10, "end": 15})
print("Page 3:", page3)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    for (let i = 0; i < 20; i++) {
        await client.query("CreateUser", {
            name: `User${i}`,
            age: 20 + (i % 40),
            email: `user${i}@example.com`
        });
    }

    const page1 = await client.query("GetUsersPaginated", {
        start: 0,
        end: 5
    });
    console.log("Page 1:", page1);

    const page2 = await client.query("GetUsersPaginated", {
        start: 5,
        end: 10
    });
    console.log("Page 2:", page2);

    const page3 = await client.query("GetUsersPaginated", {
        start: 10,
        end: 15
    });
    console.log("Page 3:", page3);
}

main().catch((err) => {
    console.error("GetUsersPaginated query failed:", err);
});
```

### Sort Results using `ORDER`

#### Syntax
```query.hx
::ORDER<Asc>(_::{property})
::ORDER<Desc>(_::{property})
```

Notes:
- Use `Asc` for ascending order and `Desc` for descending order.

#### Example 1: Sorting by age (oldest first)

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY GetUsersOldestFirst () =>
    users <- N<User>::ORDER<Desc>(_::{age})
    RETURN users

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":45,"email":"bob@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie","age":19,"email":"charlie@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Diana","age":32,"email":"diana@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Eve","age":28,"email":"eve@example.com"}'

curl -X POST \
  http://localhost:6969/GetUsersOldestFirst \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {"name": "Alice", "age": 25, "email": "alice@example.com"},
    {"name": "Bob", "age": 45, "email": "bob@example.com"},
    {"name": "Charlie", "age": 19, "email": "charlie@example.com"},
    {"name": "Diana", "age": 32, "email": "diana@example.com"},
    {"name": "Eve", "age": 28, "email": "eve@example.com"},
]

for user in users:
    client.query("CreateUser", user)

result = client.query("GetUsersOldestFirst", {})
print("Users (oldest first):", result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        { name: "Alice", age: 25, email: "alice@example.com" },
        { name: "Bob", age: 45, email: "bob@example.com" },
        { name: "Charlie", age: 19, email: "charlie@example.com" },
        { name: "Diana", age: 32, email: "diana@example.com" },
        { name: "Eve", age: 28, email: "eve@example.com" },
    ];

    for (const user of users) {
        await client.query("CreateUser", user);
    }

    const result = await client.query("GetUsersOldestFirst", {});
    console.log("Users (oldest first):", result);
}

main().catch((err) => {
    console.error("GetUsersOldestFirst query failed:", err);
});
```

#### Example 2: Sorting by age (youngest first)

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY GetUsersYoungestFirst () =>
    users <- N<User>::ORDER<Asc>(_::{age})
    RETURN users

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":45,"email":"bob@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie","age":19,"email":"charlie@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Diana","age":32,"email":"diana@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Eve","age":28,"email":"eve@example.com"}'

curl -X POST \
  http://localhost:6969/GetUsersYoungestFirst \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {"name": "Alice", "age": 25, "email": "alice@example.com"},
    {"name": "Bob", "age": 45, "email": "bob@example.com"},
    {"name": "Charlie", "age": 19, "email": "charlie@example.com"},
    {"name": "Diana", "age": 32, "email": "diana@example.com"},
    {"name": "Eve", "age": 28, "email": "eve@example.com"},
]

for user in users:
    client.query("CreateUser", user)

result = client.query("GetUsersYoungestFirst", {})
print("Users (youngest first):", result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        { name: "Alice", age: 25, email: "alice@example.com" },
        { name: "Bob", age: 45, email: "bob@example.com" },
        { name: "Charlie", age: 19, email: "charlie@example.com" },
        { name: "Diana", age: 32, email: "diana@example.com" },
        { name: "Eve", age: 28, email: "eve@example.com" },
    ];

    for (const user of users) {
        await client.query("CreateUser", user);
    }

    const result = await client.query("GetUsersYoungestFirst", {});
    console.log("Users (youngest first):", result);
}

main().catch((err) => {
    console.error("GetUsersYoungestFirst query failed:", err);
});
```

## Properties Operations
@tags: properties, access, fields, attributes, projection, select

### Property Access

#### Select Specific Properties using `{}`

##### Syntax
```query.hx
::{<property1>, <property2>, ...}
::{<property1>: <alias>, <property2>}
```

Notes:
- Property access allows you to return only the fields you need, reducing data transfer and improving query performance.

##### Example 1: Basic property selection

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY GetUserBasicInfo () =>
    users <- N<User>::RANGE(0, 10)
    RETURN users::{name, age}

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":30,"email":"bob@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie","age":28,"email":"charlie@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Diana","age":22,"email":"diana@example.com"}'

curl -X POST \
  http://localhost:6969/GetUserBasicInfo \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {"name": "Alice", "age": 25, "email": "alice@example.com"},
    {"name": "Bob", "age": 30, "email": "bob@example.com"},
    {"name": "Charlie", "age": 28, "email": "charlie@example.com"},
    {"name": "Diana", "age": 22, "email": "diana@example.com"},
]

for user in users:
    client.query("CreateUser", user)

result = client.query("GetUserBasicInfo", {})
print("User basic info:", result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        { name: "Alice", age: 25, email: "alice@example.com" },
        { name: "Bob", age: 30, email: "bob@example.com" },
        { name: "Charlie", age: 28, email: "charlie@example.com" },
        { name: "Diana", age: 22, email: "diana@example.com" },
    ];

    for (const user of users) {
        await client.query("CreateUser", user);
    }

    const result = await client.query("GetUserBasicInfo", {});
    console.log("User basic info:", result);
}

main().catch((err) => {
    console.error("GetUserBasicInfo query failed:", err);
});
```

##### Example 2: Property selection with renaming

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY GetUserDisplayInfo () =>
    users <- N<User>::RANGE(0, 10)
    RETURN users::{displayName: name, userAge: age}

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":30,"email":"bob@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie","age":28,"email":"charlie@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Diana","age":22,"email":"diana@example.com"}'

curl -X POST \
  http://localhost:6969/GetUserDisplayInfo \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {"name": "Alice", "age": 25, "email": "alice@example.com"},
    {"name": "Bob", "age": 30, "email": "bob@example.com"},
    {"name": "Charlie", "age": 28, "email": "charlie@example.com"},
    {"name": "Diana", "age": 22, "email": "diana@example.com"},
]

for user in users:
    client.query("CreateUser", user)

result = client.query("GetUserDisplayInfo", {})
print("User display info:", result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        { name: "Alice", age: 25, email: "alice@example.com" },
        { name: "Bob", age: 30, email: "bob@example.com" },
        { name: "Charlie", age: 28, email: "charlie@example.com" },
        { name: "Diana", age: 22, email: "diana@example.com" },
    ];

    for (const user of users) {
        await client.query("CreateUser", user);
    }

    const result = await client.query("GetUserDisplayInfo", {});
    console.log("User display info:", result);
}

main().catch((err) => {
    console.error("GetUserDisplayInfo query failed:", err);
});
```

#### Access IDs using `ID`

##### Syntax
```query.hx
::ID
```

Note:
- Every element in HelixDB has a unique `ID` that can be accessed using the `::ID` syntax.

##### Example 1: Getting element IDs

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY GetUserIDs () =>
    users <- N<User>::RANGE(0, 5)
    RETURN users::ID

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":30,"email":"bob@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie","age":28,"email":"charlie@example.com"}'

curl -X POST \
  http://localhost:6969/GetUserIDs \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {"name": "Alice", "age": 25, "email": "alice@example.com"},
    {"name": "Bob", "age": 30, "email": "bob@example.com"},
    {"name": "Charlie", "age": 28, "email": "charlie@example.com"},
]

for user in users:
    client.query("CreateUser", user)

result = client.query("GetUserIDs", {})
print("User IDs:", result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        { name: "Alice", age: 25, email: "alice@example.com" },
        { name: "Bob", age: 30, email: "bob@example.com" },
        { name: "Charlie", age: 28, email: "charlie@example.com" },
    ];

    for (const user of users) {
        await client.query("CreateUser", user);
    }

    const result = await client.query("GetUserIDs", {});
    console.log("User IDs:", result);
}

main().catch((err) => {
    console.error("GetUserIDs query failed:", err);
});
```

#### Include All Properties using `..`
Use the spread operator to include all properties while optionally remapping specific fields.

##### Syntax
```query.hx
::{
    <alias>: <property>, 
    ..
}
```

##### Example 1: Property aliasing with spread operator

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY GetUsersWithAlias () =>
    users <- N<User>::RANGE(0, 5)
    RETURN users::{
        userID: ID,
        ..
    }

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":30,"email":"bob@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie","age":28,"email":"charlie@example.com"}'

curl -X POST \
  http://localhost:6969/GetUsersWithAlias \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {"name": "Alice", "age": 25, "email": "alice@example.com"},
    {"name": "Bob", "age": 30, "email": "bob@example.com"},
    {"name": "Charlie", "age": 28, "email": "charlie@example.com"},
]

for user in users:
    client.query("CreateUser", user)

result = client.query("GetUsersWithAlias", {})
print("Users with alias:", result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        { name: "Alice", age: 25, email: "alice@example.com" },
        { name: "Bob", age: 30, email: "bob@example.com" },
        { name: "Charlie", age: 28, email: "charlie@example.com" },
    ];

    for (const user of users) {
        await client.query("CreateUser", user);
    }

    const result = await client.query("GetUsersWithAlias", {});
    console.log("Users with alias:", result);
}

main().catch((err) => {
    console.error("GetUsersWithAlias query failed:", err);
});
```

### Property Addition

#### Syntax
```query.hx
::{
    <new_property>: <schema_field>,
    <computed_property>: <traversal_expression>
}
```

Notes:
- Property additions allow you to compute derived values and add metadata to your query results without modifying the underlying schema.

#### Example 1: Adding computed properties with traversals

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8
}

E::Follows {
    From: User,
    To: User
}
```

- Query:
```query.hx
QUERY GetUserDetails () =>
    users <- N<User>::RANGE(0, 5)
    RETURN users::{
        userID: ID,
        followerCount: _::In<Follows>::COUNT
    }

QUERY CreateUser (name: String, age: U8) =>
    user <- AddN<User>({
        name: name,
        age: age
    })
    RETURN user

QUERY CreateFollow (follower_id: ID, following_id: ID) =>
    follower <- N<User>(follower_id)
    following <- N<User>(following_id)
    AddE<Follows>::From(follower)::To(following)
    RETURN "Success"
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":30}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie","age":28}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Diana","age":22}'

curl -X POST \
  http://localhost:6969/CreateFollow \
  -H 'Content-Type: application/json' \
  -d '{"follower_id":"<bob_id>","following_id":"<alice_id>"}'

curl -X POST \
  http://localhost:6969/CreateFollow \
  -H 'Content-Type: application/json' \
  -d '{"follower_id":"<charlie_id>","following_id":"<alice_id>"}'

curl -X POST \
  http://localhost:6969/CreateFollow \
  -H 'Content-Type: application/json' \
  -d '{"follower_id":"<diana_id>","following_id":"<alice_id>"}'

curl -X POST \
  http://localhost:6969/GetUserDetails \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {"name": "Alice", "age": 25},
    {"name": "Bob", "age": 30},
    {"name": "Charlie", "age": 28},
    {"name": "Diana", "age": 22},
]

user_ids = []
for user in users:
    result = client.query("CreateUser", user)
    user_ids.append(result[0]["user"]["id"])

for i in range(1, len(user_ids)):
    client.query("CreateFollow", {
        "follower_id": user_ids[i],
        "following_id": user_ids[0]
    })

result = client.query("GetUserDetails", {})
print("User details with follower count:", result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        { name: "Alice", age: 25 },
        { name: "Bob", age: 30 },
        { name: "Charlie", age: 28 },
        { name: "Diana", age: 22 },
    ];

    const userIds: string[] = [];
    for (const user of users) {
        const result = await client.query("CreateUser", user);
        userIds.push(result.user.id);
    }

    for (let i = 1; i < userIds.length; i++) {
        await client.query("CreateFollow", {
            follower_id: userIds[i],
            following_id: userIds[0]
        });
    }

    const result = await client.query("GetUserDetails", {});
    console.log("User details with follower count:", result);
}

main().catch((err) => {
    console.error("GetUserDetails query failed:", err);
});
```

### Property Exclusion

#### Syntax
```query.hx
::!{<property1>, <property2>, ...}
```

Notes:
- Property exclusion is useful when you want to return most properties but hide sensitive or unnecessary fields like passwords, internal IDs, or large data fields.

#### Example 1: Excluding sensitive properties

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String,
    posts: U32,
    followers: U32,
    following: U32,
    location: String
}
```

- Query:
```query.hx
QUERY GetPublicUserInfo () =>
    users <- N<User>::RANGE(0, 10)
    RETURN users::!{email, location}

QUERY CreateUser (name: String, age: U8, email: String, posts: U32, followers: U32, following: U32, location: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email,
        posts: posts,
        followers: followers,
        following: following,
        location: location
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com","posts":42,"followers":150,"following":89,"location":"New York"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":30,"email":"bob@example.com","posts":28,"followers":203,"following":156,"location":"San Francisco"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie","age":28,"email":"charlie@example.com","posts":67,"followers":89,"following":234,"location":"London"}'

curl -X POST \
  http://localhost:6969/GetPublicUserInfo \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {
        "name": "Alice",
        "age": 25,
        "email": "alice@example.com",
        "posts": 42,
        "followers": 150,
        "following": 89,
        "location": "New York"
    },
    {
        "name": "Bob",
        "age": 30,
        "email": "bob@example.com",
        "posts": 28,
        "followers": 203,
        "following": 156,
        "location": "San Francisco"
    },
    {
        "name": "Charlie",
        "age": 28,
        "email": "charlie@example.com",
        "posts": 67,
        "followers": 89,
        "following": 234,
        "location": "London"
    }
]

for user in users:
    client.query("CreateUser", user)

result = client.query("GetPublicUserInfo", {})
print("Public user info (email and location excluded):", result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        {
            name: "Alice",
            age: 25,
            email: "alice@example.com",
            posts: 42,
            followers: 150,
            following: 89,
            location: "New York"
        },
        {
            name: "Bob",
            age: 30,
            email: "bob@example.com",
            posts: 28,
            followers: 203,
            following: 156,
            location: "San Francisco"
        },
        {
            name: "Charlie",
            age: 28,
            email: "charlie@example.com",
            posts: 67,
            followers: 89,
            following: 234,
            location: "London"
        }
    ];

    for (const user of users) {
        await client.query("CreateUser", user);
    }

    const result = await client.query("GetPublicUserInfo", {});
    console.log("Public user info (email and location excluded):", result);
}

main().catch((err) => {
    console.error("GetPublicUserInfo query failed:", err);
});
```

### Property Remappings

#### Simple Remapping

##### Syntax
```query.hx
::{new_name: property_name}
::{alias: _::{property}}
```

Notes:
- You can usually use the name directly
- If you want to be more explicit or there are name clashes, you can use the `_::` operator.

##### Example 1: Basic property remapping

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY GetUserWithAlias () =>
    users <- N<User>::RANGE(0, 5)
    RETURN users::{
        userID: ID,
        displayName: name
    }

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice Johnson","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob Smith","age":30,"email":"bob@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie Brown","age":28,"email":"charlie@example.com"}'

curl -X POST \
  http://localhost:6969/GetUserWithAlias \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {"name": "Alice Johnson", "age": 25, "email": "alice@example.com"},
    {"name": "Bob Smith", "age": 30, "email": "bob@example.com"},
    {"name": "Charlie Brown", "age": 28, "email": "charlie@example.com"},
]

for user in users:
    client.query("CreateUser", user)

result = client.query("GetUserWithAlias", {})
print("Users with remapped properties:", result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        { name: "Alice Johnson", age: 25, email: "alice@example.com" },
        { name: "Bob Smith", age: 30, email: "bob@example.com" },
        { name: "Charlie Brown", age: 28, email: "charlie@example.com" },
    ];

    for (const user of users) {
        await client.query("CreateUser", user);
    }

    const result = await client.query("GetUserWithAlias", {});
    console.log("Users with remapped properties:", result);
}

main().catch((err) => {
    console.error("GetUserWithAlias query failed:", err);
});
```

#### Nested Remapping

##### Syntax
```query.hx
::|item_name|{
    field: item_name::traversal,
    nested_field: inner_item::{
        property: item_name::ID,
        ..
    }
}
```

Notes:
- If we were to access the ID using: `nested_field: ID`. It would be the ID of the `inner_item` item not the `item_name` item due to the tighter scope.
- When accessing properties in nested mappings, scope matters. Use the explicit `item_name::property` syntax to access properties from outer scopes to avoid ambiguity.

##### Example 1: User posts with nested remappings

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}

N::Post {
    title: String,
    content: String
}

E::HasPost {
    From: User,
    To: Post
}
```

- Query:
```query.hx
QUERY GetUserPosts (user_id: ID) =>
    user <- N<User>(user_id)
    posts <- user::Out<HasPost>
    RETURN user::|usr|{
        posts: posts::{
            postID: ID,
            creatorID: usr::ID,
            creatorName: usr::name,
            ..
        }
    }

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user

QUERY CreatePost (user_id: ID, title: String, content: String) =>
    user <- N<User>(user_id)
    post <- AddN<Post>({
        title: title,
        content: content
    })
    AddE<HasPost>::From(user)::To(post)
    RETURN post
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice Johnson","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/CreatePost \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"<user_id>","title":"My First Post","content":"This is my first blog post!"}'

curl -X POST \
  http://localhost:6969/CreatePost \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"<user_id>","title":"Learning GraphDB","content":"Graph databases are fascinating."}'

curl -X POST \
  http://localhost:6969/CreatePost \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"<user_id>","title":"Weekend Plans","content":"Planning to explore the city."}'

curl -X POST \
  http://localhost:6969/GetUserPosts \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"<user_id>"}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

user_result = client.query("CreateUser", {
    "name": "Alice Johnson",
    "age": 25,
    "email": "alice@example.com"
})
user_id = user_result[0]["user"]["id"]

posts = [
    {"title": "My First Post", "content": "This is my first blog post!"},
    {"title": "Learning GraphDB", "content": "Graph databases are fascinating."},
    {"title": "Weekend Plans", "content": "Planning to explore the city."},
]

for post in posts:
    client.query("CreatePost", {
        "user_id": user_id,
        "title": post["title"],
        "content": post["content"]
    })

result = client.query("GetUserPosts", {"user_id": user_id})
print("User posts with nested remappings:", result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const userResult = await client.query("CreateUser", {
        name: "Alice Johnson",
        age: 25,
        email: "alice@example.com"
    });
    const userId = userResult.user.id;

    const posts = [
        { title: "My First Post", content: "This is my first blog post!" },
        { title: "Learning GraphDB", content: "Graph databases are fascinating." },
        { title: "Weekend Plans", content: "Planning to explore the city." },
    ];

    for (const post of posts) {
        await client.query("CreatePost", {
            user_id: userId,
            title: post.title,
            content: post.content
        });
    }

    const result = await client.query("GetUserPosts", { user_id: userId });
    console.log("User posts with nested remappings:", result);
}

main().catch((err) => {
    console.error("GetUserPosts query failed:", err);
});
```

## Query Return Values
@tags: return, output, response, results, projection, formatting

### TL;DR
- Return a list of element: `RETURN users`
- Return multiple lists of elements: `RETURN users, posts`
- Project specific fields: `RETURN users::{ name, age }`
- Return IDs only: `RETURN users::ID`
- Exclude specific fields: `RETURN users::!{ email }`
- Return scalar values: `RETURN count`
- Return literal values: `RETURN "success"`
- No payload: `RETURN NONE`

Note: When using the [Python SDK](#python-sdk-helix-py-pypi), the return values are wrapped in an array for multiple query calls, so you will need to access the first element of the array to get the result of the first call.

### Return elements

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY GetAllUsers() =>
    users <- N<User>
    RETURN users
```

- Output:
```json
{
  "users": [
    { "name": "Alice", "age": 25, "email": "alice@example.com" },
    { "name": "Bob", "age": 30, "email": "bob@example.com" },
    { "name": "Charlie", "age": 28, "email": "charlie@example.com" },
  ]
}
```

### Return multiple elements

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}

N::Post {
    title: String,
    content: String
}

E::User_to_Post {
    From: User,
    To: Post
}
```

- Query:
```query.hx
QUERY GetUserAndPosts(user_id: ID) =>
    user <- N<User>(user_id)
    posts <- user::Out<User_to_Post>
    RETURN user, posts
```

- Output:
```json
{
  "user": {"name": "Alice", "age": 25, "email": "alice@example.com"},
  "posts": [ 
    {"title": "My First Post", "content": "This is my first blog post!"}, 
    ...,
  ]
}
```

### Include fields

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY FindUsers() =>
    users <- N<User>::RANGE(0, 10)
    RETURN users::{ name, age }
```

- Output:
```json
{
  "users": [
    { "name": "Alice", "age": 25 },
    { "name": "Bob", "age": 30 },
    { "name": "Charlie", "age": 28 }
  ]
}
```

### Return IDs only

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY FindUserIDs() =>
    users <- N<User>::RANGE(0, 10)
    RETURN users::ID
```

- Output:
```json
{
  "users": [
    "c2ca233f-0cd8-4fae-8136-b40593792071",
    "d3db344g-1de9-5gbf-9247-c51604803082",
    "e4ec455h-2ef0-6hcg-0358-d62715914193"
  ]
}
```

### Exclude fields

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY FindUsersNoEmail() =>
    users <- N<User>::RANGE(0, 10)
    RETURN users::!{ email }
```

- Output:
```json
{
  "users": [
    { "name": "Alice", "age": 25 },
    { "name": "Bob", "age": 30 },
    { "name": "Charlie", "age": 28 }
  ]
}
```

### Return nested elements

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}

N::Post {
    title: String,
    content: String
}

E::User_to_Post {
    From: User,
    To: Post
}
```

- Query:
```query.hx
QUERY FindFriends(user_id: ID) =>
    user <- N<User>(user_id)
    posts <- user::Out<User_to_Post>::RANGE(20)
    RETURN user::|u|{
        userID: u::ID,
        posts: posts::{
            postID: ID,
            creatorID: u::ID,
            ..
        }
    }
```

- Output:
```json
{
  "user": {
    "userID": "c2ca233f-0cd8-4fae-8136-b40593792071",
    "posts": [
      {
        "postID": "d3db344g-1de9-5gbf-9247-c51604803082",
        "creatorID": "c2ca233f-0cd8-4fae-8136-b40593792071",
        "title": "My First Post",
        "content": "This is my first blog post!"
      },
      {
        "postID": "e4ec455h-2ef0-6hcg-0358-d62715914193",
        "creatorID": "c2ca233f-0cd8-4fae-8136-b40593792071",
        "title": "Weekend Plans",
        "content": "Planning to explore the city."
      }
    ]
  }
}
```

### Return scalar values

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY CountUsers() =>
    user_count <- N<User>::COUNT
    RETURN user_count
```

- Output:
```json
{
  "user_count": 42
}
```

### Return literal values

- Schema:
```schema.hx
N::City {
    name: String,
    population: U32
}
```

- Query:
```query.hx
QUERY DeleteCity(city_id: ID) =>
    DROP N<City>(city_id)
    RETURN "success"
```

- Output:
```json
{
  "result": "success"
}
```

### Return no payload

- Schema:
```schema.hx
N::City {
    name: String,
    population: U32
}
```

- Query:
```query.hx
QUERY DeleteCityQuietly(city_id: ID) =>
    DROP N<City>(city_id)
    RETURN NONE
```

- Output:
```json
{}
```

## Conditionals
@tags: conditionals, where, filter, eq, neq, gt, gte, lt, lte, contains, startswith, endswith, and, or, not, logic

### Anonymous Traversal

#### Syntax
```query.hx
_::<traversal>::<operation>
```

#### Example 1: Filter by relationship count

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}

E::Follows {
    From: User,
    To: User
}
```

- Query:
```query.hx
QUERY GetInfluentialUsers () =>
    users <- N<User>::WHERE(_::In<Follows>::COUNT::GT(100))
    RETURN users

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user

QUERY CreateFollow (follower_id: ID, following_id: ID) =>
    follower <- N<User>(follower_id)
    following <- N<User>(following_id)
    AddE<Follows>::From(follower)::To(following)
    RETURN "Success"
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Follower1","age":20,"email":"follower1@example.com"}'

curl -X POST \
  http://localhost:6969/CreateFollow \
  -H 'Content-Type: application/json' \
  -d '{"follower_id":"<follower_id>","following_id":"<alice_id>"}'

curl -X POST \
  http://localhost:6969/GetInfluentialUsers \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {"name": "Alice", "age": 25, "email": "alice@example.com"},
    {"name": "Bob", "age": 30, "email": "bob@example.com"},
    {"name": "Charlie", "age": 28, "email": "charlie@example.com"},
]

user_ids = []
for user in users:
    result = client.query("CreateUser", user)
    user_ids.append(result[0]["user"]["id"])

for j in range(150):
    fake_user = client.query("CreateUser", {
        "name": f"Follower{j}",
        "age": 20,
        "email": f"follower{j}@example.com"
    })
    fake_id = fake_user[0]["user"]["id"]
    client.query("CreateFollow", {"follower_id": fake_id, "following_id": user_ids[0]})

result = client.query("GetInfluentialUsers", {})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        { name: "Alice", age: 25, email: "alice@example.com" },
        { name: "Bob", age: 30, email: "bob@example.com" },
        { name: "Charlie", age: 28, email: "charlie@example.com" },
    ];

    const userIds: string[] = [];
    for (const user of users) {
        const result = await client.query("CreateUser", user);
        userIds.push(result.user.id);
    }

    for (let j = 0; j < 150; j++) {
        const fakeUser = await client.query("CreateUser", {
            name: `Follower${j}`,
            age: 20,
            email: `follower${j}@example.com`,
        });
        const fakeId: string = fakeUser.user.id;
        
        await client.query("CreateFollow", {
            follower_id: fakeId,
            following_id: userIds[0]
        });
    }

    const result = await client.query("GetInfluentialUsers", {});
    console.log("Influential users:", result);
}

main().catch((err) => {
    console.error("GetInfluentialUsers query failed:", err);
});
```

#### Example 2: Property-based filtering with anonymous traversal

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String,
    status: String
}

N::Post {
    title: String,
    content: String
}

E::HasPost {
    From: User,
    To: Post
}
```

- Query:
```query.hx
QUERY GetActiveUsersWithPosts () =>
    users <- N<User>::WHERE(AND(_::{status}::EQ("active"), _::Out<HasPost>::COUNT::GT(0)))
    RETURN users

QUERY CreateUser (name: String, age: U8, email: String, status: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email,
        status: status
    })
    RETURN user

QUERY CreatePost (user_id: ID, title: String, content: String) =>
    user <- N<User>(user_id)
    post <- AddN<Post>({
        title: title,
        content: content
    })
    AddE<HasPost>::From(user)::To(post)
    RETURN post
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com","status":"active"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":30,"email":"bob@example.com","status":"active"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie","age":28,"email":"charlie@example.com","status":"inactive"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Diana","age":22,"email":"diana@example.com","status":"active"}'

curl -X POST \
  http://localhost:6969/CreatePost \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"<alice_id>","title":"My First Post","content":"This is Alice'"'"'s first post"}'

curl -X POST \
  http://localhost:6969/CreatePost \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"<bob_id>","title":"Bob'"'"'s Thoughts","content":"This is Bob'"'"'s post"}'

curl -X POST \
  http://localhost:6969/GetActiveUsersWithPosts \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {"name": "Alice", "age": 25, "email": "alice@example.com", "status": "active"},
    {"name": "Bob", "age": 30, "email": "bob@example.com", "status": "active"},
    {"name": "Charlie", "age": 28, "email": "charlie@example.com", "status": "inactive"},
    {"name": "Diana", "age": 22, "email": "diana@example.com", "status": "active"},
]

user_ids = []
for user in users:
    result = client.query("CreateUser", user)
    user_ids.append(result[0]["user"]["id"])

client.query("CreatePost", {
    "user_id": user_ids[0],
    "title": "My First Post",
    "content": "This is Alice's first post"
})

client.query("CreatePost", {
    "user_id": user_ids[1],
    "title": "Bob's Thoughts",
    "content": "This is Bob's post"
})

result = client.query("GetActiveUsersWithPosts", {})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        { name: "Alice", age: 25, email: "alice@example.com", status: "active" },
        { name: "Bob", age: 30, email: "bob@example.com", status: "active" },
        { name: "Charlie", age: 28, email: "charlie@example.com", status: "inactive" },
        { name: "Diana", age: 22, email: "diana@example.com", status: "active" },
    ];

    const userIds: string[] = [];
    for (const user of users) {
        const result = await client.query("CreateUser", user);
        userIds.push(result.user.id);
    }

    await client.query("CreatePost", {
        user_id: userIds[0],
        title: "My First Post",
        content: "This is Alice's first post"
    });

    await client.query("CreatePost", {
        user_id: userIds[1],
        title: "Bob's Thoughts",
        content: "This is Bob's post"
    });

    const result = await client.query("GetActiveUsersWithPosts", {});
    console.log("Active users with posts:", result);
}

main().catch((err) => {
    console.error("GetActiveUsersWithPosts query failed:", err);
});
```

### Conditional Steps

Note: For multiple conditions, see [Multiple Conditions Steps](#multiple-conditions-steps).

#### Filtering using `WHERE`

##### Syntax
```query.hx
::WHERE(<condition>)
::WHERE(_::{property}::COMPARISON(value))
```

Notes:
- The condition in the `WHERE` step must evaluate to a boolean value. 
- If the condition is not met, the element will be filtered out from the results.

#### Intersect traversal results using `INTERSECT`

##### Syntax
```query.hx
::INTERSECT(_::<traversal>)
```

Notes:
- `INTERSECT` requires an anonymous traversal expression (for example `_::In<HasTag>`).
- For each upstream element, Helix executes the sub-traversal and intersects returned IDs.
- If upstream is empty, or no ID appears in every sub-result, the output is empty.

##### Example: Find articles with all requested tags

- Schema:
```schema.hx
N::Article {
    title: String
}

N::Tag {
    name: String
}

E::HasTag {
    From: Article,
    To: Tag
}
```

- Query:
```query.hx
QUERY ArticlesByAllTags (tag_names: [String]) =>
    articles <- N<Tag>::WHERE(_::{name}::IS_IN(tag_names))::INTERSECT(_::In<HasTag>)
    RETURN articles
```

##### Comparison Operators

###### String, Boolean, Date, and Number Comparisons
- `::EQ(value)`: Equals (e.g. `::WHERE(_::{status}::EQ("active"))`)
- `::NEQ(value)`: Not equals (e.g. `::WHERE(_::{age}::NEQ(25))`)

###### Number and Date Comparisons
- `::GT(value)`: Greater than (e.g. `::WHERE(_::{age}::GT(25))`)
- `::LT(value)`: Less than (e.g. `::WHERE(_::{age}::LT(30))`)
- `::GTE(value)`: Greater than or equal (e.g. `::WHERE(_::{rating}::GTE(4.5))`)
- `::LTE(value)`: Less than or equal (e.g. `::WHERE(_::{priority}::LTE(2))`)

##### Example 1: Basic filtering with WHERE

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY GetAdultUsers () =>
    adult_users <- N<User>::WHERE(_::{age}::GT(18))
    RETURN adult_users

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":16,"email":"bob@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie","age":30,"email":"charlie@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Diana","age":17,"email":"diana@example.com"}'

curl -X POST \
  http://localhost:6969/GetAdultUsers \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {"name": "Alice", "age": 25, "email": "alice@example.com"},
    {"name": "Bob", "age": 16, "email": "bob@example.com"},
    {"name": "Charlie", "age": 30, "email": "charlie@example.com"},
    {"name": "Diana", "age": 17, "email": "diana@example.com"},
]

for user in users:
    client.query("CreateUser", user)

result = client.query("GetAdultUsers", {})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        { name: "Alice", age: 25, email: "alice@example.com" },
        { name: "Bob", age: 16, email: "bob@example.com" },
        { name: "Charlie", age: 30, email: "charlie@example.com" },
        { name: "Diana", age: 17, email: "diana@example.com" },
    ];

    for (const user of users) {
        await client.query("CreateUser", user);
    }

    const result = await client.query("GetAdultUsers", {});
    console.log("Adult users:", result);
}

main().catch((err) => {
    console.error("GetAdultUsers query failed:", err);
});
```

##### Example 2: String and equality filtering

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String,
    status: String
}
```

- Query:
```query.hx
QUERY GetActiveUsers (status: String) =>
    active_users <- N<User>::WHERE(_::{status}::EQ(status))
    RETURN active_users

QUERY CreateUser (name: String, age: U8, email: String, status: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email,
        status: status
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com","status":"active"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":30,"email":"bob@example.com","status":"inactive"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie","age":28,"email":"charlie@example.com","status":"active"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Diana","age":22,"email":"diana@example.com","status":"pending"}'

curl -X POST \
  http://localhost:6969/GetActiveUsers \
  -H 'Content-Type: application/json' \
  -d '{"status":"active"}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {"name": "Alice", "age": 25, "email": "alice@example.com", "status": "active"},
    {"name": "Bob", "age": 30, "email": "bob@example.com", "status": "inactive"},
    {"name": "Charlie", "age": 28, "email": "charlie@example.com", "status": "active"},
    {"name": "Diana", "age": 22, "email": "diana@example.com", "status": "pending"},
]

for user in users:
    client.query("CreateUser", user)

result = client.query("GetActiveUsers", {"status": "active"})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        { name: "Alice", age: 25, email: "alice@example.com", status: "active" },
        { name: "Bob", age: 30, email: "bob@example.com", status: "inactive" },
        { name: "Charlie", age: 28, email: "charlie@example.com", status: "active" },
        { name: "Diana", age: 22, email: "diana@example.com", status: "pending" },
    ];

    for (const user of users) {
        await client.query("CreateUser", user);
    }

    const result = await client.query("GetActiveUsers", { status: "active" });
    console.log("Active users:", result);
}

main().catch((err) => {
    console.error("GetActiveUsers query failed:", err);
});
```

#### Filter by Relationship using `EXISTS`

##### Syntax
```query.hx
EXISTS(<traversal>)
```

##### Example 1: Using EXISTS for relationship filtering

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}

E::Follows {
    From: User,
    To: User
}
```

- Query:
```query.hx
QUERY GetUsersWithFollowers () =>
    users <- N<User>::WHERE(EXISTS(_::In<Follows>))
    RETURN users

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user

QUERY CreateFollow (follower_id: ID, following_id: ID) =>
    follower <- N<User>(follower_id)
    following <- N<User>(following_id)
    AddE<Follows>::From(follower)::To(following)
    RETURN "Success"
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":30,"email":"bob@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie","age":28,"email":"charlie@example.com"}'

curl -X POST \
  http://localhost:6969/CreateFollow \
  -H 'Content-Type: application/json' \
  -d '{"follower_id":"<bob_id>","following_id":"<alice_id>"}'

curl -X POST \
  http://localhost:6969/CreateFollow \
  -H 'Content-Type: application/json' \
  -d '{"follower_id":"<charlie_id>","following_id":"<alice_id>"}'

curl -X POST \
  http://localhost:6969/GetUsersWithFollowers \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {"name": "Alice", "age": 25, "email": "alice@example.com"},
    {"name": "Bob", "age": 30, "email": "bob@example.com"},
    {"name": "Charlie", "age": 28, "email": "charlie@example.com"},
]

user_ids = []
for user in users:
    result = client.query("CreateUser", user)
    user_ids.append(result[0]["user"]["id"])

client.query("CreateFollow", {"follower_id": user_ids[1], "following_id": user_ids[0]})
client.query("CreateFollow", {"follower_id": user_ids[2], "following_id": user_ids[0]})

result = client.query("GetUsersWithFollowers", {})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        { name: "Alice", age: 25, email: "alice@example.com" },
        { name: "Bob", age: 30, email: "bob@example.com" },
        { name: "Charlie", age: 28, email: "charlie@example.com" },
    ];

    const userIds: string[] = [];
    for (const user of users) {
        const result = await client.query("CreateUser", user);
        userIds.push(result.user.id);
    }

    await client.query("CreateFollow", {
        follower_id: userIds[1],
        following_id: userIds[0]
    });

    await client.query("CreateFollow", {
        follower_id: userIds[2],
        following_id: userIds[0]
    });

    const result = await client.query("GetUsersWithFollowers", {});
    console.log("Users with followers:", result);
}

main().catch((err) => {
    console.error("GetUsersWithFollowers query failed:", err);
});
```

### Multiple Conditions Steps

Filter by multiple conditions using `AND` and/or `OR`.

#### Syntax
```query.hx
::WHERE(AND(<condition1>, <condition2>, ...))
::WHERE(OR(<condition1>, <condition2>, ...))
```

#### Example 1: Using AND for range filtering

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY GetYoungAdults () =>
    users <- N<User>::WHERE(AND(_::{age}::GT(18), _::{age}::LT(30)))
    RETURN users

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":16,"email":"bob@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie","age":35,"email":"charlie@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Diana","age":22,"email":"diana@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Eve","age":17,"email":"eve@example.com"}'

curl -X POST \
  http://localhost:6969/GetYoungAdults \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {"name": "Alice", "age": 25, "email": "alice@example.com"},
    {"name": "Bob", "age": 16, "email": "bob@example.com"},
    {"name": "Charlie", "age": 35, "email": "charlie@example.com"},
    {"name": "Diana", "age": 22, "email": "diana@example.com"},
    {"name": "Eve", "age": 17, "email": "eve@example.com"},
]

for user in users:
    client.query("CreateUser", user)

result = client.query("GetYoungAdults", {})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        { name: "Alice", age: 25, email: "alice@example.com" },
        { name: "Bob", age: 16, email: "bob@example.com" },
        { name: "Charlie", age: 35, email: "charlie@example.com" },
        { name: "Diana", age: 22, email: "diana@example.com" },
        { name: "Eve", age: 17, email: "eve@example.com" },
    ];

    for (const user of users) {
        await client.query("CreateUser", user);
    }

    const result = await client.query("GetYoungAdults", {});
    console.log("Young adults:", result);
}

main().catch((err) => {
    console.error("GetYoungAdults query failed:", err);
});
```

#### Example 2: Using OR for multiple valid options

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY GetSpecificUsers () =>
    users <- N<User>::WHERE(OR(_::{name}::EQ("Alice"), _::{name}::EQ("Bob")))
    RETURN users

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":30,"email":"bob@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie","age":28,"email":"charlie@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Diana","age":22,"email":"diana@example.com"}'

curl -X POST \
  http://localhost:6969/GetSpecificUsers \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {"name": "Alice", "age": 25, "email": "alice@example.com"},
    {"name": "Bob", "age": 30, "email": "bob@example.com"},
    {"name": "Charlie", "age": 28, "email": "charlie@example.com"},
    {"name": "Diana", "age": 22, "email": "diana@example.com"},
]

for user in users:
    client.query("CreateUser", user)

result = client.query("GetSpecificUsers", {})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        { name: "Alice", age: 25, email: "alice@example.com" },
        { name: "Bob", age: 30, email: "bob@example.com" },
        { name: "Charlie", age: 28, email: "charlie@example.com" },
        { name: "Diana", age: 22, email: "diana@example.com" },
    ];

    for (const user of users) {
        await client.query("CreateUser", user);
    }

    const result = await client.query("GetSpecificUsers", {});
    console.log("Specific users:", result);
}

main().catch((err) => {
    console.error("GetSpecificUsers query failed:", err);
});
```

#### Example 3: Complex nested AND and OR conditions

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY GetFilteredUsers () =>
    users <- N<User>::WHERE(
        AND(
            _::{age}::GT(18),
            OR(_::{name}::EQ("Alice"), _::{name}::EQ("Bob"))
        )
    )
    RETURN users

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":16,"email":"bob@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":17,"email":"alice2@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie","age":30,"email":"charlie@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":22,"email":"bob2@example.com"}'

curl -X POST \
  http://localhost:6969/GetFilteredUsers \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {"name": "Alice", "age": 25, "email": "alice@example.com"},
    {"name": "Bob", "age": 16, "email": "bob@example.com"},
    {"name": "Alice", "age": 17, "email": "alice2@example.com"},
    {"name": "Charlie", "age": 30, "email": "charlie@example.com"},
    {"name": "Bob", "age": 22, "email": "bob2@example.com"},
]

for user in users:
    client.query("CreateUser", user)

result = client.query("GetFilteredUsers", {})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        { name: "Alice", age: 25, email: "alice@example.com" },
        { name: "Bob", age: 16, email: "bob@example.com" },
        { name: "Alice", age: 17, email: "alice2@example.com" },
        { name: "Charlie", age: 30, email: "charlie@example.com" },
        { name: "Bob", age: 22, email: "bob2@example.com" },
    ];

    for (const user of users) {
        await client.query("CreateUser", user);
    }

    const result = await client.query("GetFilteredUsers", {});
    console.log("Filtered users:", result);
}

main().catch((err) => {
    console.error("GetFilteredUsers query failed:", err);
});
```

## Vector Operations
@tags: vector, search, similarity, embedding, searchV, embed, cosine, euclidean, hnsw

### Vector Search using `SearchV`

#### Syntax
```query.hx
SearchV<Type>(vector, limit)
```

Note: Currently only supports `[F64]` to represent the vector. Support for `[F32]` and binary vectors added in the future.

#### Example 1: Basic vector search

- Schema:
```schema.hx
V::Document {
    content: String,
    created_at: Date
}
```

- Query:
```query.hx
QUERY SearchVector (vector: [F64], limit: I64) =>
    documents <- SearchV<Document>(vector, limit)
    RETURN documents

QUERY InsertVector (vector: [F64], content: String, created_at: Date) =>
    document <- AddV<Document>(vector, { content: content, created_at: created_at })
    RETURN document
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/InsertVector \
  -H 'Content-Type: application/json' \
  -d '{"vector":[0.1,0.2,0.3,0.4],"content":"Sample document content","created_at":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"}'

curl -X POST \
  http://localhost:6969/SearchVector \
  -H 'Content-Type: application/json' \
  -d '{"vector":[0.1,0.2,0.3,0.4],"limit":10}'
```

- Python SDK:
```python
from datetime import datetime, timezone
from helix.client import Client

client = Client(local=True, port=6969)

vector_data = [0.1, 0.2, 0.3, 0.4]
inserted = client.query("InsertVector", {
    "vector": vector_data,
    "content": "Sample document content",
    "created_at": datetime.now(timezone.utc).isoformat(),
})

result = client.query("SearchVector", {
    "vector": vector_data,
    "limit": 10
})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const vectorData = [0.1, 0.2, 0.3, 0.4];

    const inserted = await client.query("InsertVector", {
        vector: vectorData,
        content: "Sample document content",
        created_at: new Date().toISOString(),
    });

    const result = await client.query("SearchVector", {
        vector: vectorData,
        limit: 10,
    });

    console.log("Search results:", result);
}

main().catch((err) => {
    console.error("SearchVector query failed:", err);
});
```

#### Example 2: Vector search with postfiltering

- Schema:
```schema.hx
V::Document {
    content: String,
    created_at: Date
}
```

- Query:
```query.hx
QUERY SearchRecentDocuments (vector: [F64], limit: I64, cutoff_date: Date) =>
    documents <- SearchV<Document>(vector, limit)::WHERE(_::{created_at}::GTE(cutoff_date))
    RETURN documents

QUERY InsertVector (vector: [F64], content: String, created_at: Date) =>
    document <- AddV<Document>(vector, { content: content, created_at: created_at })
    RETURN document
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/InsertVector \
  -H 'Content-Type: application/json' \
  -d '{"vector":[0.12,0.34,0.56,0.78],"content":"Recent document content","created_at":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"}'

curl -X POST \
  http://localhost:6969/InsertVector \
  -H 'Content-Type: application/json' \
  -d '{"vector":[0.15,0.35,0.55,0.75],"content":"Old document content","created_at":"'"$(date -u -d '45 days ago' +"%Y-%m-%dT%H:%M:%SZ")"'"}'

curl -X POST \
  http://localhost:6969/SearchRecentDocuments \
  -H 'Content-Type: application/json' \
  -d '{"vector":[0.12,0.34,0.56,0.78],"limit":5,"cutoff_date":"'"$(date -u -d '30 days ago' +"%Y-%m-%dT%H:%M:%SZ")"'"}'
```

- Python SDK:
```python
from datetime import datetime, timezone, timedelta
from helix.client import Client

client = Client(local=True, port=6969)

vector_data = [0.12, 0.34, 0.56, 0.78]

recent_date = datetime.now(timezone.utc).isoformat()
old_date = (datetime.now(timezone.utc) - timedelta(days=45)).isoformat()

client.query("InsertVector", {
    "vector": vector_data,
    "content": "Recent document content",
    "created_at": recent_date,
})

client.query("InsertVector", {
    "vector": [0.15, 0.35, 0.55, 0.75],
    "content": "Old document content", 
    "created_at": old_date,
})

cutoff_date = (datetime.now(timezone.utc) - timedelta(days=30)).isoformat()

result = client.query("SearchRecentDocuments", {
    "vector": vector_data,
    "limit": 5,
    "cutoff_date": cutoff_date,
})

print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const vectorData = [0.12, 0.34, 0.56, 0.78];

    const recentDate = new Date().toISOString();
    const oldDate = new Date(Date.now() - 45 * 24 * 60 * 60 * 1000).toISOString();

    await client.query("InsertVector", {
        vector: vectorData,
        content: "Recent document content",
        created_at: recentDate,
    });

    await client.query("InsertVector", {
        vector: [0.15, 0.35, 0.55, 0.75],
        content: "Old document content",
        created_at: oldDate,
    });

    const cutoffDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();

    const result = await client.query("SearchRecentDocuments", {
        vector: vectorData,
        limit: 5,
        cutoff_date: cutoffDate,
    });

    console.log("Filtered search results:", result);
}

main().catch((err) => {
    console.error("SearchRecentDocuments query failed:", err);
});
```

####  Example 3: Using the built in [Embed function](#embedding-vectors-using-embed)

- Built-in `Embed` function: don't need to send array of floats, just send the text.

- Schema:
```schema.hx
V::Document {
    content: String,
    created_at: Date
}
```

- Query:
```query.hx
QUERY SearchWithText (text: String, limit: I64) =>
    documents <- SearchV<Document>(Embed(text), limit)
    RETURN documents

QUERY InsertTextAsVector (content: String, created_at: Date) =>
    document <- AddV<Document>(Embed(content), { content: content, created_at: created_at })
    RETURN document
```

- Environment variables (OpenAI example):
```.env
OPENAI_API_KEY=your_api_key
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/InsertTextAsVector \
  -H 'Content-Type: application/json' \
  -d '{"content":"Introduction to machine learning algorithms","created_at":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"}'

curl -X POST \
  http://localhost:6969/InsertTextAsVector \
  -H 'Content-Type: application/json' \
  -d '{"content":"Deep neural networks and AI","created_at":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"}'

curl -X POST \
  http://localhost:6969/InsertTextAsVector \
  -H 'Content-Type: application/json' \
  -d '{"content":"Natural language processing techniques","created_at":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"}'

curl -X POST \
  http://localhost:6969/SearchWithText \
  -H 'Content-Type: application/json' \
  -d '{"text":"machine learning algorithms","limit":10}'
```

- Python SDK:
```python
from datetime import datetime, timezone
from helix.client import Client

client = Client(local=True, port=6969)

sample_texts = [
    "Introduction to machine learning algorithms",
    "Deep neural networks and AI",
    "Natural language processing techniques"
]

for text in sample_texts:
    client.query("InsertTextAsVector", {
        "content": text,
        "created_at": datetime.now(timezone.utc).isoformat(),
    })

result = client.query("SearchWithText", {
    "text": "machine learning algorithms",
    "limit": 10,
})

print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const sampleTexts = [
        "Introduction to machine learning algorithms",
        "Deep neural networks and AI",
        "Natural language processing techniques"
    ];

    for (const text of sampleTexts) {
        await client.query("InsertTextAsVector", {
            content: text,
            created_at: new Date().toISOString(),
        });
    }

    const result = await client.query("SearchWithText", {
        text: "machine learning algorithms",
        limit: 10,
    });

    console.log("Text search results:", result);
}

main().catch((err) => {
    console.error("SearchWithText query failed:", err);
});
```

### Embedding Vectors using `Embed`

#### Syntax
```query.hx
AddV<Type>(Embed(text))
AddV<Type>(Embed(text), {properties})
SearchV<Type>(Embed(text), limit)
```

Notes (outdated, will be updated in the future):
- The text is automatically embedded with an embedding model of your choice (can be defined in your config.hx.json file). 
- The default embedding model is text-embedding-ada-002 from OpenAI.
- Make sure to set your OPENAI_API_KEY environment variable with your API key in the same location as the queries.hx, schema.hx and config.hx.json files. 

#### Example 1: Creating a vector from text

- Schema:
```schema.hx
V::Document {
    content: String,
    created_at: Date
}
```

- Query:
```query.hx
QUERY InsertTextAsVector (content: String, created_at: Date) =>
    document <- AddV<Document>(Embed(content), { content: content, created_at: created_at })
    RETURN document
```

- Environment variables (OpenAI example):
```.env
OPENAI_API_KEY=your_api_key
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/InsertTextAsVector \
  -H 'Content-Type: application/json' \
  -d '{"content":"Machine learning is transforming the way we work.","created_at":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"}'
```

- Python SDK:
```python
from datetime import datetime, timezone
from helix.client import Client

client = Client(local=True, port=6969)

print(client.query("InsertTextAsVector", {
    "content": "Machine learning is transforming the way we work.",
    "created_at": datetime.now(timezone.utc).isoformat(),
}))
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const result = await client.query("InsertTextAsVector", {
        content: "Machine learning is transforming the way we work.",
        created_at: new Date().toISOString(),
    });

    console.log("Created document vector:", result);
}

main().catch((err) => {
    console.error("InsertTextAsVector query failed:", err);
});
```

#### Example 2: Searching with text embeddings

- Schema:
```schema.hx
V::Document {
    content: String,
    created_at: Date
}
```

- Query:
```query.hx
QUERY SearchWithText (query: String, limit: I64) =>
    documents <- SearchV<Document>(Embed(query), limit)
    RETURN documents

QUERY InsertTextAsVector (content: String, created_at: Date) =>
    document <- AddV<Document>(Embed(content), { content: content, created_at: created_at })
    RETURN document
```

- Environment variables (OpenAI example):
```.env
OPENAI_API_KEY=your_api_key
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/InsertTextAsVector \
  -H 'Content-Type: application/json' \
  -d '{"content":"Artificial intelligence is revolutionizing automation","created_at":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"}'

curl -X POST \
  http://localhost:6969/InsertTextAsVector \
  -H 'Content-Type: application/json' \
  -d '{"content":"Machine learning algorithms for predictive analytics","created_at":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"}'

curl -X POST \
  http://localhost:6969/InsertTextAsVector \
  -H 'Content-Type: application/json' \
  -d '{"content":"Deep learning applications in computer vision","created_at":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"}'

curl -X POST \
  http://localhost:6969/SearchWithText \
  -H 'Content-Type: application/json' \
  -d '{"query":"artificial intelligence and automation","limit":5}'
```

- Python SDK:
```python
from datetime import datetime, timezone
from helix.client import Client

client = Client(local=True, port=6969)

sample_texts = [
    "Artificial intelligence is revolutionizing automation",
    "Machine learning algorithms for predictive analytics",
    "Deep learning applications in computer vision"
]

for text in sample_texts:
    client.query("InsertTextAsVector", {
        "content": text,
        "created_at": datetime.now(timezone.utc).isoformat(),
    })

result = client.query("SearchWithText", {
    "query": "artificial intelligence and automation",
    "limit": 5,
})

print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const sampleTexts = [
        "Artificial intelligence is revolutionizing automation",
        "Machine learning algorithms for predictive analytics",
        "Deep learning applications in computer vision"
    ];

    for (const text of sampleTexts) {
        await client.query("InsertTextAsVector", {
            content: text,
            created_at: new Date().toISOString(),
        });
    }

    const result = await client.query("SearchWithText", {
        query: "artificial intelligence and automation",
        limit: 5,
    });

    console.log("Search results:", result);
}

main().catch((err) => {
    console.error("SearchWithText query failed:", err);
});
```

#### Example 3: Creating a vector and connecting it to a user

- Schema:
```schema.hx
N::User {
    name: String,
    email: String
}

V::Document {
    content: String,
    created_at: Date
}

E::User_to_Document_Embedding {
    From: User,
    To: Document,
}
```

- Query:
```query.hx
QUERY CreateUserDocument (user_id: ID, content: String, created_at: Date) =>
    document <- AddV<Document>(Embed(content), { content: content, created_at: created_at })
    edge <- AddE<User_to_Document_Embedding>::From(user_id)::To(document)
    RETURN document

QUERY CreateUser (name: String, email: String) =>
    user <- AddN<User>({
        name: name,
        email: email
    })
    RETURN user
```

- Environment variables (OpenAI example):
```.env
OPENAI_API_KEY=your_api_key
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice Johnson","email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUserDocument \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"<user_id>","content":"This is my personal note about project planning.","created_at":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"}'
```

- Python SDK:
```python
from datetime import datetime, timezone
from helix.client import Client

client = Client(local=True, port=6969)

user = client.query("CreateUser", {
    "name": "Alice Johnson",
    "email": "alice@example.com",
})
user_id = user[0]["user"]["id"]

result = client.query("CreateUserDocument", {
    "user_id": user_id,
    "content": "This is my personal note about project planning.",
    "created_at": datetime.now(timezone.utc).isoformat(),
})

print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const user = await client.query("CreateUser", {
        name: "Alice Johnson",
        email: "alice@example.com",
    });
    const userId: string = user.user.id;

    const result = await client.query("CreateUserDocument", {
        user_id: userId,
        content: "This is my personal note about project planning.",
        created_at: new Date().toISOString(),
    });

    console.log("Created user document:", result);
}

main().catch((err) => {
    console.error("CreateUserDocument query failed:", err);
});
```

#### Example 4: Semantic search with postfiltering

- Schema:
```schema.hx
V::Document {
    content: String,
    created_at: Date
}
```

- Query:
```query.hx
QUERY SearchRecentNotes (query: String, limit: I64, cutoff_date: Date) =>
    documents <- SearchV<Document>(Embed(query), limit)
                    ::WHERE(_::{created_at}::GTE(cutoff_date))
    RETURN documents

QUERY InsertTextAsVector (content: String, created_at: Date) =>
    document <- AddV<Document>(Embed(content), { content: content, created_at: created_at })
    RETURN document
```

- Environment variables (OpenAI example):
```.env
OPENAI_API_KEY=your_api_key
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/InsertTextAsVector \
  -H 'Content-Type: application/json' \
  -d '{"content":"Project milestone review scheduled for next week","created_at":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"}'

curl -X POST \
  http://localhost:6969/InsertTextAsVector \
  -H 'Content-Type: application/json' \
  -d '{"content":"Weekly status report from last month","created_at":"'"$(date -u -d '10 days ago' +"%Y-%m-%dT%H:%M:%SZ")"'"}'

curl -X POST \
  http://localhost:6969/SearchRecentNotes \
  -H 'Content-Type: application/json' \
  -d '{"query":"project deadlines and milestones","limit":10,"cutoff_date":"'"$(date -u -d '7 days ago' +"%Y-%m-%dT%H:%M:%SZ")"'"}'
```

- Python SDK:
```python
from datetime import datetime, timezone, timedelta
from helix.client import Client

client = Client(local=True, port=6969)

recent_date = datetime.now(timezone.utc).isoformat()
old_date = (datetime.now(timezone.utc) - timedelta(days=10)).isoformat()

client.query("InsertTextAsVector", {
    "content": "Project milestone review scheduled for next week",
    "created_at": recent_date,
})

client.query("InsertTextAsVector", {
    "content": "Weekly status report from last month",
    "created_at": old_date,
})

cutoff_date = (datetime.now(timezone.utc) - timedelta(days=7)).isoformat()

result = client.query("SearchRecentNotes", {
    "query": "project deadlines and milestones",
    "limit": 10,
    "cutoff_date": cutoff_date,
})

print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const recentDate = new Date().toISOString();
    const oldDate = new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString();

    await client.query("InsertTextAsVector", {
        content: "Project milestone review scheduled for next week",
        created_at: recentDate,
    });

    await client.query("InsertTextAsVector", {
        content: "Weekly status report from last month",
        created_at: oldDate,
    });

    const cutoffDate = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString();

    const result = await client.query("SearchRecentNotes", {
        query: "project deadlines and milestones",
        limit: 10,
        cutoff_date: cutoffDate,
    });

    console.log("Recent search results:", result);
}

main().catch((err) => {
    console.error("SearchRecentNotes query failed:", err);
});
```

## Keyword Search
@tags: keyword, search, bm25, text-search, full-text, ranking

Search for keywords in nodes using BM25 algorithm.

### Syntax
```query.hx
SearchBM25<Type>(text, limit)
```

Notes:
- BM25 is a ranking function used for full-text search. 
- It searches through the text properties of nodes and ranks results based on keyword relevance and frequency.
- Make sure you enable BM25 in your `helix.toml` file.

### Example 1: Basic keyword search

- Schema:
```schema.hx
N::Document {
    content: String,
    created_at: Date
}
```

- Query:
```query.hx
QUERY SearchKeyword (keywords: String, limit: I64) =>
    documents <- SearchBM25<Document>(keywords, limit)
    RETURN documents

QUERY InsertDocument (content: String, created_at: Date) =>
    document <- AddN<Document>({ content: content, created_at: created_at })
    RETURN document
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/InsertDocument \
  -H 'Content-Type: application/json' \
  -d '{"content":"Machine learning algorithms for data analysis","created_at":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"}'

curl -X POST \
  http://localhost:6969/InsertDocument \
  -H 'Content-Type: application/json' \
  -d '{"content":"Introduction to artificial intelligence and neural networks","created_at":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"}'

curl -X POST \
  http://localhost:6969/InsertDocument \
  -H 'Content-Type: application/json' \
  -d '{"content":"Database optimization techniques and performance tuning","created_at":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"}'

curl -X POST \
  http://localhost:6969/SearchKeyword \
  -H 'Content-Type: application/json' \
  -d '{"keywords":"machine learning algorithms","limit":5}'
```

- Python SDK:
```python
from datetime import datetime, timezone
from helix.client import Client

client = Client(local=True, port=6969)

sample_docs = [
    "Machine learning algorithms for data analysis",
    "Introduction to artificial intelligence and neural networks",
    "Database optimization techniques and performance tuning",
    "Web development with modern JavaScript frameworks"
]

for content in sample_docs:
    client.query("InsertDocument", {
        "content": content,
        "created_at": datetime.now(timezone.utc).isoformat(),
    })

result = client.query("SearchKeyword", {
    "keywords": "machine learning algorithms",
    "limit": 5
})

print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const sampleDocs = [
        "Machine learning algorithms for data analysis",
        "Introduction to artificial intelligence and neural networks",
        "Database optimization techniques and performance tuning",
        "Web development with modern JavaScript frameworks"
    ];

    for (const content of sampleDocs) {
        await client.query("InsertDocument", {
            content: content,
            created_at: new Date().toISOString(),
        });
    }

    const result = await client.query("SearchKeyword", {
        keywords: "machine learning algorithms",
        limit: 5
    });

    console.log("Search results:", result);
}

main().catch((err) => {
    console.error("SearchKeyword query failed:", err);
});
```

### Example 2: Keyword search with postfiltering

- Schema:
```schema.hx
N::Document {
    content: String,
    created_at: Date
}
```

- Query:
```query.hx
QUERY SearchRecentKeywords (keywords: String, limit: I64, cutoff_date: Date) =>
    searched_docs <- SearchBM25<Document>(keywords, limit)
    documents <- searched_docs::WHERE(_::{created_at}::GTE(cutoff_date))
    RETURN documents

QUERY InsertDocument (content: String, created_at: Date) =>
    document <- AddN<Document>({ content: content, created_at: created_at })
    RETURN document
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/InsertDocument \
  -H 'Content-Type: application/json' \
  -d '{"content":"Modern machine learning techniques in 2024","created_at":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"}'

curl -X POST \
  http://localhost:6969/InsertDocument \
  -H 'Content-Type: application/json' \
  -d '{"content":"Latest artificial intelligence research papers","created_at":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"}'

curl -X POST \
  http://localhost:6969/InsertDocument \
  -H 'Content-Type: application/json' \
  -d '{"content":"Traditional machine learning approaches from last year","created_at":"'"$(date -u -d '15 days ago' +"%Y-%m-%dT%H:%M:%SZ")"'"}'

curl -X POST \
  http://localhost:6969/SearchRecentKeywords \
  -H 'Content-Type: application/json' \
  -d '{"keywords":"machine learning artificial intelligence","limit":5,"cutoff_date":"'"$(date -u -d '10 days ago' +"%Y-%m-%dT%H:%M:%SZ")"'"}'
```

- Python SDK:
```python
from datetime import datetime, timezone, timedelta
from helix.client import Client

client = Client(local=True, port=6969)

recent_date = datetime.now(timezone.utc).isoformat()
old_date = (datetime.now(timezone.utc) - timedelta(days=15)).isoformat()

recent_docs = [
    "Modern machine learning techniques in 2024",
    "Latest artificial intelligence research papers"
]

for content in recent_docs:
    client.query("InsertDocument", {
        "content": content,
        "created_at": recent_date,
    })

old_docs = [
    "Traditional machine learning approaches from last year",
    "Historical AI development milestones"
]

for content in old_docs:
    client.query("InsertDocument", {
        "content": content,
        "created_at": old_date,
    })

cutoff_date = (datetime.now(timezone.utc) - timedelta(days=10)).isoformat()

result = client.query("SearchRecentKeywords", {
    "keywords": "machine learning artificial intelligence",
    "limit": 5,
    "cutoff_date": cutoff_date,
})

print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const recentDate = new Date().toISOString();
    const oldDate = new Date(Date.now() - 15 * 24 * 60 * 60 * 1000).toISOString();

    const recentDocs = [
        "Modern machine learning techniques in 2024",
        "Latest artificial intelligence research papers"
    ];

    for (const content of recentDocs) {
        await client.query("InsertDocument", {
            content: content,
            created_at: recentDate,
        });
    }

    const oldDocs = [
        "Traditional machine learning approaches from last year",
        "Historical AI development milestones"
    ];

    for (const content of oldDocs) {
        await client.query("InsertDocument", {
            content: content,
            created_at: oldDate,
        });
    }

    const cutoffDate = new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString();

    const result = await client.query("SearchRecentKeywords", {
        keywords: "machine learning artificial intelligence",
        limit: 5,
        cutoff_date: cutoffDate,
    });

    console.log("Filtered search results:", result);
}

main().catch((err) => {
    console.error("SearchRecentKeywords query failed:", err);
});
```

## Rerankers
@tags: reranker, rerank, ranking, relevance, rrf, mmr, hybrid, diversify

### What are rerankers?
- Combine results from multiple search strategies (hybrid search)
- Reduce redundancy by diversifying results
- Optimize the relevance-diversity trade-off
- Improve the overall user experience of your search application

### When to use rerankers?
- Merge multiple search methods: Combine vector search with BM25 keyword search, or merge results from multiple vector searches
- Diversify results: Eliminate near-duplicate content and show varied perspectives
- Optimize ranking: Fine-tune the balance between relevance and variety based on your use case
- Improve search quality: Leverage sophisticated ranking algorithms without changing your underlying search infrastructure

### Best practices for reranking
- Retrieve more results initially: Fetch 100-200 candidates to give rerankers sufficient options to work with
- Apply rerankers before RANGE: Rerank first, then limit the number of results returned
- Choose the right reranker: Use RRF for combining searches, MMR for diversification
- Test with your data: Experiment with different parameters to find what works best for your use case

### Reciprocal Rank Fusion using `RerankRRF`

- Combine multiple ranked lists without requiring score calibration.
- Good for merging results from different search methods.

#### Syntax
```query.hx
::RerankRRF             // Uses default k=60
::RerankRRF(k: 30.0)    // Custom k parameter
```

#### Example: Hybrid search fusion

- Schema:
```schema.hx
V::Document {
    content: String,
    created_at: Date
}
```

- Query:
```query.hx
QUERY SearchDocuments(query_vec: [F64]) =>
    results <- SearchV<Document>(query_vec, 100)
        ::RerankRRF             // Apply reranking
        ::RANGE(0, 10)          // Get top 10 results
    RETURN results
```

### Maximal Marginal Relevance using `RerankMMR`

- Balances relevance with diversity to reduce redundancy. 
- Good for showing varied results instead of similar or duplicate content.

#### Syntax
```query.hx
::RerankMMR(lambda: 0.7)
```

#### Example: Simple diversification

- Schema:
```schema.hx
V::Document {
    content: String,
    created_at: Date
}
```

- Query:
```query.hx
QUERY SearchDocuments(query_vec: [F64]) =>
    results <- SearchV<Document>(query_vec, 100)
        ::RerankMMR(lambda: 0.7)  // Apply reranking
        ::RANGE(0, 10)            // Get top 10 results
    RETURN results
```

### Chaining Rerankers

#### Example: Fusion and diversification

- Schema:
```schema.hx
V::Document {
    content: String,
    created_at: Date
}
```

- Query:
```query.hx
QUERY AdvancedSearch(query_vec: [F64]) =>
    results <- SearchV<Document>(query_vec, 150)
        ::RerankRRF(k: 60)       // First: combine multiple rankings
        ::RerankMMR(lambda: 0.6) // Then: diversify results
        ::RANGE(0, 10)
    RETURN results
```

## Aggregation
@tags: aggregation, group-by, count, statistics, analytics, grouping, distribution

### Group by Properties

`GROUP_BY` returns count summaries for each unique combination of the specified properties, useful for analytics and data distribution analysis.

#### Syntax
```query.hx
::GROUP_BY(property1, property2, ...)
```

- Output:
```json
[
    {"property": 25, "count": 3}, 
    {"property": 30, "count": 2},
    {"property": 35, "count": 1},
    ...
]
```

#### Example 1: Group users by age

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY GroupUsersByAge () =>
    users <- N<User>
    RETURN users::GROUP_BY(age)

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","age":25,"email":"alice@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","age":30,"email":"bob@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie","age":25,"email":"charlie@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Diana","age":30,"email":"diana@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Eve","age":35,"email":"eve@example.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Frank","age":25,"email":"frank@example.com"}'

curl -X POST \
  http://localhost:6969/GroupUsersByAge \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {"name": "Alice", "age": 25, "email": "alice@example.com"},
    {"name": "Bob", "age": 30, "email": "bob@example.com"},
    {"name": "Charlie", "age": 25, "email": "charlie@example.com"},
    {"name": "Diana", "age": 30, "email": "diana@example.com"},
    {"name": "Eve", "age": 35, "email": "eve@example.com"},
    {"name": "Frank", "age": 25, "email": "frank@example.com"},
]

for user in users:
    client.query("CreateUser", user)

result = client.query("GroupUsersByAge", {})
print("Users grouped by age:", result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        { name: "Alice", age: 25, email: "alice@example.com" },
        { name: "Bob", age: 30, email: "bob@example.com" },
        { name: "Charlie", age: 25, email: "charlie@example.com" },
        { name: "Diana", age: 30, email: "diana@example.com" },
        { name: "Eve", age: 35, email: "eve@example.com" },
        { name: "Frank", age: 25, email: "frank@example.com" },
    ];

    for (const user of users) {
        await client.query("CreateUser", user);
    }

    const result = await client.query("GroupUsersByAge", {});
    console.log("Users grouped by age:", result);
}

main().catch((err) => {
    console.error("GroupUsersByAge query failed:", err);
});
```

### Aggregate by Properties

`AGGREGATE_BY` returns the full data objects grouped by the specified properties, providing both count and the actual grouped elements for detailed analysis.

#### Syntax
```query.hx
::AGGREGATE_BY(property1, property2, ...)
```

- Output:
```json
[
    {
        "count": 3,
        "data": [
            {"property1": 25, "property2": "Alice", ...},
            {"property1": 25, "property2": "Charlie", ...},
            {"property1": 25, "property2": "Frank", ...}
        ]
    },
    {
        "count": 2,
        "data": [
            {"property1": 30, "property2": "Bob", ...},
            {"property1": 30, "property2": "Diana", ...}
        ]
    },
    ...
]
```

#### Example 1: Aggregate users by age and email domain

- Schema:
```schema.hx
N::User {
    name: String,
    age: U8,
    email: String
}
```

- Query:
```query.hx
QUERY AggregateUsersByAge () =>
    users <- N<User>
    RETURN users::AGGREGATE_BY(age)

QUERY CreateUser (name: String, age: U8, email: String) =>
    user <- AddN<User>({
        name: name,
        age: age,
        email: email
    })
    RETURN user
```

- cURL:
```bash
curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice Johnson","age":25,"email":"alice@company.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob Smith","age":30,"email":"bob@startup.io"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Charlie Brown","age":25,"email":"charlie@company.com"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Diana Prince","age":30,"email":"diana@enterprise.org"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Eve Wilson","age":35,"email":"eve@freelance.net"}'

curl -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Frank Miller","age":25,"email":"frank@startup.io"}'

curl -X POST \
  http://localhost:6969/AggregateUsersByAge \
  -H 'Content-Type: application/json' \
  -d '{}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

users = [
    {"name": "Alice Johnson", "age": 25, "email": "alice@company.com"},
    {"name": "Bob Smith", "age": 30, "email": "bob@startup.io"},
    {"name": "Charlie Brown", "age": 25, "email": "charlie@company.com"},
    {"name": "Diana Prince", "age": 30, "email": "diana@enterprise.org"},
    {"name": "Eve Wilson", "age": 35, "email": "eve@freelance.net"},
    {"name": "Frank Miller", "age": 25, "email": "frank@startup.io"},
]

for user in users:
    client.query("CreateUser", user)

result = client.query("AggregateUsersByAge", {})
print("Users aggregated by age:", result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const users = [
        { name: "Alice Johnson", age: 25, email: "alice@company.com" },
        { name: "Bob Smith", age: 30, email: "bob@startup.io" },
        { name: "Charlie Brown", age: 25, email: "charlie@company.com" },
        { name: "Diana Prince", age: 30, email: "diana@enterprise.org" },
        { name: "Eve Wilson", age: 35, email: "eve@freelance.net" },
        { name: "Frank Miller", age: 25, email: "frank@startup.io" },
    ];

    for (const user of users) {
        await client.query("CreateUser", user);
    }

    const result = await client.query("AggregateUsersByAge", {});
    console.log("Users aggregated by age:", result);
}

main().catch((err) => {
    console.error("AggregateUsersByAge query failed:", err);
});
```

## Macros
@tags: macros, mcp, model-context-protocol, ai-agents, decorators, annotations

### Model Context Protocol (MCP) Macro

`#[mcp]` macro exposes any query as an MCP endpoint, making it directly accessible to AI agents.

Notes:
- MCP queries must return a single object/value from the query otherwise you will get a compile error. 
- Make sure to enable MCP in your `helix.toml` file.

#### Best Practices for MCP Macros
- Use descriptive query names: choose names that are easy for AI agents to understand and use.
- Keep query signatures simple: avoid complex parameters or nested structures.

#### Syntax
```query.hx
#[mcp]
QUERY QueryName(param1: Type, param2: Type) =>
    result <- traversal_expression
    RETURN result
```

#### Example

- Schema:
```schema.hx
N::User {
    name: String,
    age: U32,
    email: String
}
```

- Query:
```query.hx
#[mcp]
QUERY get_user(user_id: ID) =>
    user <- N<User>(user_id)
    RETURN user
```

- cURL:
```bash
# Initialize the connection, this will return a connection_id
curl -X POST \
  http://localhost:6969/mcp/init \    
  -H 'Content-Type: application/json' \
  -d '{}'

# Use the connection_id from above to call the MCP endpoint
curl -X POST \
  http://localhost:6969/mcp/get_userMcp \
  -H 'Content-Type: application/json' \
  -d '{
    "connection_id": "connection_id",
    "data": {
        "user_id": "user_id"
      }
    }'
```

- Python SDK:
```python
from helix.client import Client
from helix.mcp import MCPServer
from helix.providers.openai_client import OpenAIProvider
from fastmcp.tools.tool import FunctionTool

# Initialize MCP server
client = Client(local=True)
mcp = MCPServer("helix-mcp", client)

# Add your custom tool to the MCP server
def get_user(connection_id: str, user_id: str):
    """
    Get the name of a user by their ID
    Args: connection_id: The connection ID, user_id: The ID of the user
    Returns: The user object
    """
    return client.query(
        "mcp/get_userMcp", 
        {"connection_id": connection_id, "data":{"user_id": user_id}}
    )

mcp.add_tool(FunctionTool.from_function(get_user))

# Start MCP server
mcp.run_bg()

# Enable MCP in your LLM provider
llm = OpenAIProvider(
    name="openai-llm",
    instructions="You are a helpful assistant with access to user data.",
    model="gpt-4o",
    history=True
)
llm.enable_mcps("helix-mcp")

# The AI can now call your MCP queries
response = llm.generate(f"What is the name of user with ID {user_id}?")
print(response)
```

## Shortest Path Algorithms
@tags: shortest-path, algorithms, bfs, dijkstra, pathfinding, graph-algorithms

### Default Algorithm (BFS) using `::ShortestPath`

Notes:
- Breadth-first search finds the minimum number of hops between nodes along a specific edge type. 
- This is the default algorithm for backward compatibility.

#### Syntax
```query.hx
::ShortestPath<EdgeType>::To(to_id: ID)
::ShortestPath<EdgeType>::From(from_id: ID)
```

### Breadth-first Search Algorithm using `::ShortestPathBFS`

#### Syntax
```query.hx
::ShortestPathBFS<EdgeType>::To(to_id: ID)
::ShortestPathBFS<EdgeType>::From(from_id: ID)
```

### Dijkstra's Algorithm using `::ShortestPathDijkstra`

Notes:
- Dijkstra's algorithm finds the path with minimum total weight by summing edge weights. 
- Requires specifying which edge property to use as weight.
- Edge weights must be numeric (integers or floats) and non-negative.

#### Syntax
```query.hx
::ShortestPathDijkstras<EdgeType>(_::{weight_property})::To(to_id: ID)
::ShortestPathDijkstras<EdgeType>(_::{weight_property})::From(from_id: ID)
```

### Return Type for Shortest Path Algorithms

The shortest-path result is an array of tuples because multiple equally short routes can be returned.

```json
[([Node1, Node2, ...], [Edge1, Edge2, ...]), ...]
```

### Algorithm Selection Rules
| Algorithm | Use Case | Optimizes For | Edge Weights |
|-----------|----------|---------------|--------------|
| `ShortestPath` (BFS) | Social networks, network hops, simple routing | Minimum number of edges/hops | Ignored |
| `ShortestPathBFS` | Same as above (explicit) | Minimum number of edges/hops | Ignored |
| `ShortestPathDijkstras` | GPS routing, cost optimization, weighted graphs | Minimum total weight/cost | Required |

### Examples

#### Example 1: BFS vs Dijkstra comparison
Consider this graph:
```graph
A -> B (distance: 100km, 1 hop)
A -> C -> B (distance: 30km + 40km = 70km, 2 hops)
```

- `BFS` will choose `A -> B` (1 hop, shorter path by hop count).
- `Dijkstra` will choose `A -> C -> B` (70km total, shorter path by weight).

#### Example 2: Finding routes between locations

- Schema:
```schema.hx
N::Location {
    name: String,
}

E::Road {
    From: Location,
    To: Location,
    Properties: {
        distance_km: U32,
    }
}
```

- Query:
```query.hx
QUERY GetShortestPath (from_id: ID, to_id: ID) =>
    path <- N<Location>(from_id)::ShortestPath<Road>::To(to_id)
    RETURN path

QUERY CreateLocation (name: String) =>
    location <- AddN<Location>({
        name: name,
    })
    RETURN location

QUERY ConnectLocations (from_id: ID, to_id: ID, distance_km: U32) =>
    road <- AddE<Road>({
        distance_km: distance_km,
    })::From(from_id)::To(to_id)
    RETURN road
```

- cURL:
```bash
central=$(curl -s -X POST \
  http://localhost:6969/CreateLocation \
  -H 'Content-Type: application/json' \
  -d '{"name":"Central Station"}')
central_id=$(echo "$central" | jq -r '.location.id')

market=$(curl -s -X POST \
  http://localhost:6969/CreateLocation \
  -H 'Content-Type: application/json' \
  -d '{"name":"Market Square"}')
market_id=$(echo "$market" | jq -r '.location.id')

harbor=$(curl -s -X POST \
  http://localhost:6969/CreateLocation \
  -H 'Content-Type: application/json' \
  -d '{"name":"Harbor"}')
harbor_id=$(echo "$harbor" | jq -r '.location.id')

curl -X POST \
  http://localhost:6969/ConnectLocations \
  -H 'Content-Type: application/json' \
  -d '{"from_id":"'"$central_id"'","to_id":"'"$market_id"'","distance_km":2}'

curl -X POST \
  http://localhost:6969/ConnectLocations \
  -H 'Content-Type: application/json' \
  -d '{"from_id":"'"$market_id"'","to_id":"'"$harbor_id"'","distance_km":3}'

curl -X POST \
  http://localhost:6969/GetShortestPath \
  -H 'Content-Type: application/json' \
  -d '{"from_id":"'"$central_id"'","to_id":"'"$harbor_id"'"}'
```

- Python SDK:
```python
from helix.client import Client

client = Client(local=True, port=6969)

central = client.query("CreateLocation", {"name": "Central Station"})
market = client.query("CreateLocation", {"name": "Market Square"})
harbor = client.query("CreateLocation", {"name": "Harbor"})

central_id = central[0]["location"]["id"]
market_id = market[0]["location"]["id"]
harbor_id = harbor[0]["location"]["id"]

client.query("ConnectLocations", {
    "from_id": central_id,
    "to_id": market_id,
    "distance_km": 2,
})
client.query("ConnectLocations", {
    "from_id": market_id,
    "to_id": harbor_id,
    "distance_km": 3,
})

result = client.query("GetShortestPath", {
    "from_id": central_id,
    "to_id": harbor_id,
})
print(result)
```

- TypeScript SDK:
```typescript
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const central = await client.query("CreateLocation", {
        name: "Central Station",
    });
    const market = await client.query("CreateLocation", {
        name: "Market Square",
    });
    const harbor = await client.query("CreateLocation", {
        name: "Harbor",
    });

    await client.query("ConnectLocations", {
        from_id: central.location.id,
        to_id: market.location.id,
        distance_km: 2,
    });

    await client.query("ConnectLocations", {
        from_id: market.location.id,
        to_id: harbor.location.id,
        distance_km: 3,
    });

    const result = await client.query("GetShortestPath", {
        from_id: central.location.id,
        to_id: harbor.location.id,
    });

    console.log("GetShortestPath result:", result);
}

main().catch((err) => {
    console.error("GetShortestPath query failed:", err);
});
```

## Errors
@tags: errors, error-codes, debugging, troubleshooting, validation, compile-errors, query, query-errors

### E101: Unknown Node Type
Reference a node type that is not defined in `schema.hx`.

#### Example

- Schema:
```schema.hx
// no types defined
```

- Query:
```query.hx
QUERY getUser(id: ID) =>
    user <- N<User>(id)
    RETURN user
```

#### Solution

Define the node type `User` in `schema.hx`.

- Schema:
```schema.hx
N::User {
    // fields
}
```

### E102: Unknown Edge Type

Reference an edge type that is not defined in `schema.hx`.

#### Example

- Schema:
```schema.hx
N::User {
    // fields
}

N::Post {
    // fields
}
```

- Query:
```query.hx
QUERY getUsersPosts(id: ID) =>
    posts <- N<User>(id)::Out<Posted>
    RETURN posts
```

#### Solution

Define the edge type `Posted` in `schema.hx`.

- Schema:
```schema.hx
N::User {
    // fields
}

N::Post {
// fields
}

E::Posted {
    From: User,
    To: Post,
}
```

### E103: Unknown Vector Type

Reference a vector type that is not defined in `schema.hx`.

#### Example

- Schema:
```schema.hx
// no types defined
```

- Query:
```query.hx
QUERY search(query: String) =>
    results <- SearchV<Document>(Embed(query), 10)
    RETURN results
```

#### Solution

Define the vector type `Document` in `schema.hx`.

- Schema:
```schema.hx
V::Document {
    // fields
}
```

### E105: Invalid Identifier

Use an invalid identifier in `query.hx`.

#### Example

`Out` is a reserved keyword so it cannot be used as a variable or a parameter name.

- Query:
```query.hx
QUERY getUser(id: ID) =>
    Out <- N<User>(id)
    RETURN Out

QUERY getUser(Out: ID) =>
    user <- N<User>(Out)
    RETURN user
```

#### Solution

Rename the variable or parameter to a valid identifier.

- Query:
```query.hx
QUERY getUser(id: ID) =>
    user <- N<User>(id)
    RETURN user

QUERY getUser(id: ID) =>
    user <- N<User>(id)
    RETURN user
```

### E202: Field Not in Schema

Reference a field that is not defined in `schema.hx` for a given item type.

#### Example

The field `username` is not defined in `schema.hx` for the `User` item type.

- Schema:
```schema.hx
N::User {
    age: U32,
}
```

- Query:
```query.hx
QUERY getUser(id: ID) =>
    user <- N<User>(id)
    RETURN user::{username}
```

#### Solution

Define the field `username` in `schema.hx` for the `User` item type.

- Schema:
```schema.hx
N::User {
    username: String,
    age: U32,
}
```

### E204: Reserved Field Name

Use a reserved field name in `schema.hx` or `query.hx`.

#### Example

The field `id` is a reserved field name for any item type.

- Schema:
```schema.hx
N::User {
    id: String,
}
```

#### Solution

Rename the field to a valid identifier.

- Schema:
```schema.hx
N::User {
    github_id: String,
}
```

### E205: Type Mismatch

Occurs when the type of a value you’re providing doesn’t match the expected field type defined in `schema.hx`.

#### Example

- Schema:
```schema.hx
N::User {
    someField: String,
}
```

- Query:
```query.hx
QUERY addUser(someField: U32) =>
    user <- AddN<User>({someField: someField})
    RETURN user
```

#### Solution

Change type of `someField` to `String` or `U32`.

- Schema:
```schema.hx
N::User {
    someField: U32,
}
```

- Query:
```query.hx
QUERY addUser(someField: U32) =>
    user <- AddN<User>({someField: someField})
    RETURN user
```

### E207: Invalid Edge Type for Item

Use an edge type that exists in `schema.hx` but is not valid for the specific item type you’re working with.

#### Example

In this example, the `Created` edge exists. However, it goes from `User` to `Post`, not from `Post` to `User`. Therefore, it is not valid for an `Out` step from a `Post` node.

- Schema:
```schema.hx
N::User {
    // Fields
}

N::Post {
    // Fields
}

E::Created {
    From: User,
    To: Post,
}
```

- Query:
```query.hx
Query getUserFromPost(postId: ID) =>
    user <- N<Post>(postId)::Out<Created>
    RETURN user
```

#### Solution

Change the traversal to use the `In` step instead of the `Out` step.

- Query:
```query.hx
Query getUserFromPost(postId: ID) =>
    user <- N<Post>(postId)::In<Created>
```

### E301: Variable Not in Scope

Reference a variable that is not currently in scope or has not been declared.

#### Example

The variable `userId` is not declared.

- Query:
```query.hx
Query getUser() =>
    user <- N<User>(userId)
    RETURN user
```

#### Solution

Declare the variable `userId` as a parameter before using it.

- Query:
```query.hx
Query getUser(userId: ID) =>
    user <- N<User>(userId)
    RETURN user
```

### E302: Variable Previously Declared

Declare a variable that has already been declared in the current scope.

#### Example

In this example, the variable `userId` is declared twice.

- Query:
```query.hx
Query getUser(userId: ID) =>
    userId <- N<User>(userId)::ID
    RETURN userId
```

#### Solution

Use a different variable name.

- Query:
```query.hx
Query getUser(userId: ID) =>
    user_id <- N<User>(userId)::ID
    RETURN user_id
```

### E304: Missing Item Type

An item type is required but not provided in your query.

#### Example

The `User` item type is required but not provided.

- Query:
```query.hx
Query getUser(userId: ID) =>
    user <- N(userId)
    RETURN user

Query getUser(userId: ID) =>
    user <- N<User>(userId)::Out
    RETURN user
```

#### Solution

Specify the required item type within the `<` and `>` brackets after the traversal step in your query.

- Query:
```query.hx
Query getUser(userId: ID) =>
    user <- N<User>(userId)::Out<Knows>
    RETURN user
```

### E305: Missing Parameter

A required parameter is missing from a function call or operation.

#### Example

The `SearchV` function is called without the `k` parameter which is required to limit the number of results.

- Query:
```query.hx
Query searchUsers(vector: [F64]) =>
    users <- SearchV<Document>(vector)
    RETURN users
```

#### Solution

Provide all required parameters for functions and operations.

- Query:
```query.hx
Query searchUsers(vector: [F64]) =>
    users <- SearchV<Document>(vector, 10)
    RETURN users
```

### E401: MCP Single Value Requirement

An MCP (Model Context Protocol) query returns multiple values when only a single value is expected.

#### Example

The MCP query returns multiple users, but MCP expects a single value.

- Query:
```query.hx
#[mcp]
Query getUsers(userId: ID, postId: ID) =>
    user <- N<User>(userId)
    post <- N<Post>(postId)
    RETURN user, post
```

#### Solution

Ensure MCP queries return exactly one value.

- Query:
```query.hx
#[mcp]
Query getUsers(userId: ID, postId: ID) =>
    user <- N<User>(userId)
    post <- N<Post>(postId)
    RETURN user
```

### E501: Invalid Date

Provide a date value that cannot be parsed or is in an invalid format.

#### Example

The date value `"2023-99-99"` is invalid and cannot be parsed.

- Schema:
```schema.hx
N::Event {
    date: Date,
}
```

- Query:
```query.hx
Query addEvent() =>
    AddN<Event>({date: "2023-99-99"})
```

#### Solution

Ensure the date value is in the correct format.

- Query:
```query.hx
Query addEvent() =>
    AddN<Event>({date: "2023-01-01"})
```

### E601: Invalid Traversal

Attempt to perform a malformed traversal.

Note: This error is not currently emitted by the compiler.

#### Example

- Query:
```query.hx
Query getUser() =>
    user <- N()
```

#### Solution

- Query:
```query.hx
Query getUser() =>
    user <- N<User>
    RETURN user
```

### E602: Invalid Step

Use a step that is not valid in the current context.

#### Example

The `OutE<Knows>` step results in edges, but the `Out` step can only be used on nodes.

- Schema:
```schema.hx
N::User {
    // fields
}

E::Knows {
    From: User,
    To: User,
}
```

- Query:
```query.hx
Query getUser() =>
    user <- N<User>::OutE<Knows>::Out<Knows>
    RETURN user
```

#### Solution

- Query:
```query.hx
Query getUser() =>
    user <- N<User>::Out<Knows>::Out<Knows>
    RETURN user
```

### E604: Update Restriction

Performing an update operation on something other than nodes or edges.

#### Example

The update step is used on a vector type which is not allowed yet.

- Query:
```query.hx
V::Vector {
    field1: String,
}
```

### E611: Missing To ID

Create an edge without specifying the target node ID.

#### Example

The `AddE` step is used without specifying the `To` parameter.

- Query:
```query.hx
Query addEdge(from: ID, to: ID) =>
    AddE<Follows>::From(from)
```

#### Solution

Provide both `From` and `To` node IDs when creating edges.

- Query:
```query.hx
Query addEdge(from: ID, to: ID) =>
    AddE<Follows>::From(from)::To(to)
```

### E612: Missing From ID

Create an edge without specifying the source node ID.

#### Example

The `AddE` step is used without specifying the `From` parameter.

- Query:
```query.hx
Query addEdge(to: ID) =>
    AddE<Follows>::To(to)
```

#### Solution

Provide both `From` and `To` node IDs when creating edges.

- Query:
```query.hx
Query addEdge(from: ID, to: ID) =>
    AddE<Follows>::From(from)::To(to)
```

### E621: Invalid Boolean Comparison

Apply a boolean comparison operation to a type that doesn’t support it.

#### Example

- Schema:
```schema.hx
N::User {
    name: String,
}
```

- Query:
```query.hx
Query getUser(user1: ID, user2: ID) =>
    user1 <- N<User>(user1)
    user2 <- N<User>(user2)
    is_eq <- user1::EQ(user2)
    RETURN is_eq
```

#### Solution

Ensure boolean operations are used on values that result in primitive types like booleans, numbers, or strings.

- Query:
```query.hx
Query getUser(user1: ID, user2: ID) =>
    user1_name <- N<User>(user1)::{name}
    user2_name <- N<User>(user2)::{name}
    is_eq <- user1_name::EQ(user2_name)
    RETURN is_eq
```

### E622: Type Mismatch in Comparison

Compare a property with a value of a different type.

#### Example

- Schema:
```schema.hx
N::User {
    name: String,
    age: I64,
}
```

- Query:
```query.hx
Query getUser(user: ID) =>
    user <- N<User>(user)
    is_eq <- user::{name}::EQ(25)
    RETURN is_eq
```

#### Solution

- Query:
```query.hx
Query getUser(user: ID) =>
    user <- N<User>(user)
    is_eq <- user::{age}::EQ(25)
    RETURN is_eq
```

### E631: Incomplete Range

Define a range without both start and end values.

#### Example

- Query:
```query.hx
Query getUser() =>
    subset_of_users <- N<User>::RANGE(0)
    RETURN subset_of_users
```

#### Solution

- Query:
```query.hx
Query getUser() =>
    subset_of_users <- N<User>::RANGE(0, 100)
    RETURN subset_of_users
```

### E632: Invalid Range Order

The start value of a range is greater than or equal to the end value. This error is only emitted by the compiler when both start and end values are provided as literals. A runtime error will be emitted if the range is not valid at runtime.

#### Example

The start value is greater than the end value.

- Query:
```query.hx
Query getUser() =>
    subset_of_users <- N<User>::RANGE(100, 10)
    RETURN subset_of_users
```

#### Solution

Ensure range start value is less than end value.

- Query:
```query.hx
Query getUser() =>
    subset_of_users <- N<User>::RANGE(10, 100)
    RETURN subset_of_users
```

### E633: Non-Integer Range Index

Use a non-integer value as an index in a range operation.

#### Example

The range index is a float value which is not allowed.

- Query:
```query.hx
Query getUser() =>
    subset_of_users <- N<User>::RANGE(1.5, 4.9)
    RETURN subset_of_users

Query getUser(end: F32) =>
    subset_of_users <- N<User>::RANGE(0, end)
    RETURN subset_of_users
```

#### Solution

Use integer values for range indices or set variable types to integer types.

- Query:
```query.hx
Query getUser() =>
    subset_of_users <- N<User>::RANGE(1, 5)
    RETURN subset_of_users
    
Query getUser(end: I64) =>
    subset_of_users <- N<User>::RANGE(0, end)
    RETURN subset_of_users
```

### E641: Closure Position Restriction

Place a closure operation in a position other than the last step of a traversal.

#### Example

The closure is not at the end of the traversal.

- Query:
```query.hx
Query getUser(userId: ID) =>
    user <- N<User>(userId)
    RETURN user::|u|{
                userID: u::ID
            }::Out<Knows>
```

#### Solution

Move the closure to the last step of the traversal.

- Query:
```query.hx
Query getUser(userId: ID) =>
    user <- N<User>(userId)
    out_users <- user::Out<Knows>
    RETURN out_users, user::|u|{
                            userID: u::ID
                        }
```

### E642: Object Position Restriction

Place an object operation in a position other than the last step of a traversal.

#### Example

The object is not at the end of the traversal.

- Query:
```query.hx
Query getUser(userId: ID) =>
    user <- N<User>(userId)
    RETURN user::{
                userID: ID
            }::Out<Knows>
```

#### Solution

Move the object to the last step of the traversal.

- Query:
```query.hx
Query getUser(userId: ID) =>
    user <- N<User>(userId)
    out_users <- user::Out<Knows>
    RETURN out_users, user::{
                            userID: ID
                        }::Out<Knows>
```

### E643: Field Previously Excluded

Access or include a field that has been previously excluded in the traversal.

#### Example

The email field is excluded in the traversal, but is being included.

- Query:
```query.hx
Query getUser(userId: ID) =>
    user <- N<User>(userId)::!{email}
    RETURN user::{email}
```

#### Solution

Remove the exclusion or access the field after the exclusion.

- Query:
```query.hx
Query getUser(userId: ID) =>
    user <- N<User>(userId)
    RETURN user::{email}
```

### E644: Exclude Position Restriction

Place an exclude operation in a position other than the last step of a traversal or the step before an object remapping or closure remapping step.

#### Example

The exclude step is used before the `Out<Knows>` step which is not allowed.

- Query:
```query.hx
Query getUser(userId: ID) =>
    users <- N<User>(userId)::!{email}::Out<Knows>
    RETURN users
```

#### Solution

Move the exclude step to the last step of the traversal or the step before an object remapping or closure remapping step.

- Query:
```query.hx
Query getUser(userId: ID) =>
    users <- N<User>(userId)::Out<Knows>::!{email}
    RETURN users
```

### E645

Define an object remapping with no fields.

#### Example

- Schema:
```schema.hx
N::User {
    name: String,
}
```

- Query:
```query.hx
Query getUser(userId: ID) =>
    user <- N<User>(userId)
    RETURN user::{}
```

#### Solution

- Query:
```query.hx
Query getUser(userId: ID) =>
    user <- N<User>(userId)
    RETURN user::{name}
```

### E651: Non-Iterable Variable

Use a non-iterable variable in an iteration context.

#### Example

The parameter `name` is not iterable, so it cannot be used in an iteration context.

- Query:
```query.hx
Query addUser(name: String) =>
    FOR n IN name {
        AddN<User>({name: n})
    }
    RETURN "User added"
```

#### Solution

Ensure variables used in iterations are collections or arrays.

- Query:
```query.hx
Query addUser(names: [String]) =>
    FOR n IN names {
        AddN<User>({name: n})
    }
    RETURN "Users added"
```

### E652: Invalid Field Access

Access a field that doesn't exist on the inner type of an iterable variable.

#### Example

The `nonexistent_field` field doesn't exist on the inner type of the `userData` iterable variable.

- Query:
```query.hx
Query addUser(userData: [{name: String, age: I64}]) =>
    FOR { name, age, nonexistent_field } IN userData {
        AddN<User>({name: name, age: age})
    }
    RETURN "Users added"
```

#### Solution

Ensure to only access fields that exist on the inner type.

- Query:
```query.hx
Query addUser(userData: [{name: String, age: I64}]) =>
    FOR { name, age } IN userData {
        AddN<User>({name: name, age: age})
    }
    RETURN "Users added"
```

### E653: Non-Object Inner Type

The inner type of an iterable variable is not an object type, preventing field access or object destructuring.

#### Example

The `names` variable contains strings, not objects, so field access is not allowed.

- Query:
```query.hx
Query addUsers(names: [String]) =>
    FOR {name} In names {
        AddN<User>({name: name})
    }
    RETURN "Users added"
```

#### Solution

Ensure iterable contains object types for field access.

- Query:
```query.hx
Query addUsers(names: [String]) =>
    FOR name IN names {
        AddN<User>({name: name})
    }
    RETURN "Users added"

Query addUsers(names: [{name: String}]) =>
    FOR {name} IN names {
        AddN<User>({name: name})
    }
    RETURN "Users added"
```
