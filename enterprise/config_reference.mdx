---
title: "HyperScale Cluster Configuration"
description: "A comprehensive reference for all dashboard configuration options available with Helix Hyperscale."
sidebarTitle:  "Configuration"
icon: "gear"
---

## Cluster Configuration Options

### Cluster Modes

Helix supports two cluster modes to match your deployment needs:

| Feature | Dev Mode | HA Mode |
|---------|----------|---------|
| Purpose | Testing/Development | Production |
| Instance Count | 1 gateway + 1 DB (fixed) | 3-100 (configurable) |
| API Authentication | None | Enabled |
| Logging Level | Verbose (debugging) | Reduced (production) |

#### Storage Persistence
Your data persists in the same Object Storage location regardless of which mode you're running. Switching from Dev to HA mode preserves all your dataâ€”only the nodes change, and data is loaded dynamically. This means you can start with Dev mode for testing, then upgrade to HA mode when you're ready for production.

---

### Instance Configuration (HA Mode)

<Info>
Instance configuration only applies to HA mode clusters. Dev mode clusters are fixed at 1 gateway and 1 database node.
</Info>

HA clusters run a minimum of 3 gateway and 3 database nodes for high availability. The system automatically scales instances based on demand, up to your configured maximum. Gateway count always equals database count.

| Setting | Min | Max | Default |
|---------|-----|-----|---------|
| Instances | 3 | 100 | 3-5 |

Need more than 100 instances? Contact support.

---

### Database Node Architecture

Database nodes use a writer/reader architecture:

- **1 writer node** handles all write operations
- **Remaining nodes are readers** and handle read queries
- Gateway nodes are all equivalent (no writer/reader distinction)

This architecture ensures write consistency while allowing read operations to scale horizontally across reader nodes.

---

### Gateway Node Architecture

Gateway nodes handle request routing based on query type:

- **Incoming requests** are distributed across gateway nodes via load balancing
- **Gateways analyze each query** to determine if it's a read or write operation
- **Write queries** are routed to the writer database node
- **Read queries** are distributed across reader database nodes

This routing layer ensures write operations maintain consistency through the single writer node while read operations can scale horizontally across all reader nodes.

---

## Advanced

These settings control low-level database behavior. Modify with caution.

<ResponseField name="Flush Interval" type="milliseconds" default={200}>
  Controls how often data is flushed from memory (memtable) to disk as SST files.

  - Lower values: Better durability (less data loss on crash), but increased disk I/O
  - Higher values: Better write throughput, but more data at risk in memory
</ResponseField>

<ResponseField name="L0 SST Size" type="bytes" default={1024 * 1024 * 1024}>
  Target size for SST files created at Level 0 during flush operations.

  - Larger values: Fewer files created, reduced compaction overhead, but longer individual flush times
  - Smaller values: More granular files, faster flushes, but more compaction work
</ResponseField>

<ResponseField name="Poll Interval" type="milliseconds" default={50}>
  How frequently the system checks for new data or events.

  - Lower values: More responsive to changes, but higher CPU usage
  - Higher values: Reduced CPU overhead, but increased latency for detecting changes
</ResponseField>

<ResponseField name="L0 Max SSTs Default" type="number" default={100}>
  Maximum number of SST files allowed at Level 0 before compaction is triggered.

  - Higher values: Better sustained write throughput, but slower read performance (more files to search)
  - Lower values: Faster reads, but more frequent compaction and write amplification
</ResponseField>

<ResponseField name="L0 Max SSTs Vector" type="number" default={100}>
  Maximum L0 SST files for the vector index (separate from graph data).

  - Higher values: Better vector ingestion throughput during bulk loads
  - Lower values: Faster vector similarity searches, but more compaction during writes
</ResponseField>

<ResponseField name="Vector Block Cache Size" type="bytes" default={1024 * 1024 * 1024}>
  Memory allocated for caching frequently accessed vectors.

  - Higher values: Faster vector queries (more cache hits), reduced disk I/O
  - Lower values: Lower memory footprint, but slower queries due to more disk reads

  <Warning>Over-allocating can cause memory pressure on the system.</Warning>
</ResponseField>
