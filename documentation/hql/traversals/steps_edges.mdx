---
title: "Traversals From Edges"
description: "Move from an edge to its connected nodes or vectors."
icon: ""
---

Return the node that the edge originates from.

```rust
::FromN
```

### Example 1: Getting the user from a document creation edge

<CodeGroup>
```rust Query focus={1-3} [expandable]
QUERY GetCreatorFromEdge (creation_id: ID) =>
    creator <- E<Creates>(creation_id)::FromN
    RETURN creator

QUERY CreateUser (name: String, email: String) =>
    user <- AddN<User>({
        name: name,
        email: email,
    })
    RETURN user

QUERY CreateDocument (user_id: ID, content: String, vector: [F64]) =>
    document <- AddV<Document>(vector, {
        content: content
    })
    creation_edge <- AddE<Creates>::From(user_id)::To(document)
    RETURN creation_edge
```

```rust Schema
N::User {
    name: String,
    email: String,
}

V::Document {
    content: String
}

E::Creates {
    From: User,
    To: Document
}
```

</CodeGroup>

<CodeGroup>
```python Python [expandable]
from helix.client import Client

client = Client(local=True, port=6969)

alice = client.query("CreateUser", {"name": "Alice", "email": "alice@example.com"})
alice_id = alice[0]["user"]["id"]

creation = client.query("CreateDocument", {
    "user_id": alice_id,
    "content": "This is my first document",
    "vector": [0.1, 0.2, 0.3, 0.4, 0.5],
})
creation_id = creation[0]["creation_edge"]["id"]

result = client.query("GetCreatorFromEdge", {
    "creation_id": creation_id,
})
print(result)
```

```rust Rust [expandable]
use helix_rs::{HelixDB, HelixDBClient};
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = HelixDB::new(Some("http://localhost"), Some(6969), None);

    let alice: serde_json::Value = client.query("CreateUser", &json!({
        "name": "Alice",
        "email": "alice@example.com",
    })).await?;
    let alice_id = alice["user"]["id"].as_str().unwrap().to_string();

    let creation: serde_json::Value = client.query("CreateDocument", &json!({
        "user_id": alice_id,
        "content": "This is my first document",
        "vector": [0.1, 0.2, 0.3, 0.4, 0.5],
    })).await?;
    let creation_id = creation["creation_edge"]["id"].as_str().unwrap().to_string();

    let result: serde_json::Value = client.query("GetCreatorFromEdge", &json!({
        "creation_id": creation_id,
    })).await?;
    println!("GetCreatorFromEdge result: {result:#?}");

    Ok(())
}
```

```go Go [expandable]
package main

import (
    "fmt"
    "log"

    "github.com/HelixDB/helix-go"
)

func main() {
    client := helix.NewClient("http://localhost:6969")

    var alice map[string]any
    if err := client.Query("CreateUser",
        helix.WithData(map[string]any{"name": "Alice", "email": "alice@example.com"}),
    ).Scan(&alice); err != nil {
        log.Fatalf("CreateUser (Alice) failed: %s", err)
    }

    aliceID := alice["user"].(map[string]any)["id"].(string)

    var creation map[string]any
    if err := client.Query("CreateDocument",
        helix.WithData(map[string]any{
            "user_id": aliceID,
            "content": "This is my first document",
            "vector": []float64{0.1, 0.2, 0.3, 0.4, 0.5},
        }),
    ).Scan(&creation); err != nil {
        log.Fatalf("CreateDocument failed: %s", err)
    }

    creationID := creation["creation_edge"].(map[string]any)["id"].(string)

    var result map[string]any
    if err := client.Query("GetCreatorFromEdge",
        helix.WithData(map[string]any{"creation_id": creationID}),
    ).Scan(&result); err != nil {
        log.Fatalf("GetCreatorFromEdge failed: %s", err)
    }

    fmt.Printf("GetCreatorFromEdge result: %#v\n", result)
}
```

```typescript TypeScript [expandable]
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");

    const alice = await client.query("CreateUser", {
        name: "Alice",
        email: "alice@example.com",
    });

    const creation = await client.query("CreateDocument", {
        user_id: alice.user.id,
        content: "This is my first document",
        vector: [0.1, 0.2, 0.3, 0.4, 0.5],
    });

    const result = await client.query("GetCreatorFromEdge", {
        creation_id: creation.creation_edge.id,
    });

    console.log("GetCreatorFromEdge result:", result);
}

main().catch((err) => {
    console.error("GetCreatorFromEdge query failed:", err);
});
```

```bash Curl [expandable]
alice=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","email":"alice@example.com"}')
alice_id=$(echo "$alice" | jq -r '.user.id')

creation=$(curl -s -X POST \
  http://localhost:6969/CreateDocument \
  -H 'Content-Type: application/json' \
  -d '{"user_id":"'"$alice_id"'","content":"This is my first document","vector":[0.1,0.2,0.3,0.4,0.5]}')
creation_id=$(echo "$creation" | jq -r '.creation_edge.id')

curl -s -X POST \
  http://localhost:6969/GetCreatorFromEdge \
  -H 'Content-Type: application/json' \
  -d '{"creation_id":"'"$creation_id"'"}'
```

</CodeGroup>

---

## `::FromV` &nbsp; Source Vector

Return the vector (node plus its properties) that the edge originates from.

```rust
::FromV
```

### Example 1: Inspecting the document vector from edge

<CodeGroup>
```rust Query focus={1-3} [expandable]
QUERY GetDocumentVector (creation_id: ID) =>
    document_vector <- E<Creates>(creation_id)::ToV
    RETURN document_vector

QUERY CreateUser (name: String, email: String) =>
    user <- AddN<User>({
        name: name,
        email: email,
    })
    RETURN user

QUERY CreateDocument (user_id: ID, content: String, vector: [F64]) =>
    document <- AddV<Document>(vector, {
        content: content
    })
    creation_edge <- AddE<Creates>::From(user_id)::To(document)
    RETURN creation_edge
```

```rust Schema
N::User {
    name: String,
    email: String,
}

V::Document {
    content: String
}

E::Creates {
    From: User,
    To: Document
}
```

</CodeGroup>

<CodeGroup>
```python Python [expandable]
from helix.client import Client
from datetime import datetime, timezone

client = Client(local=True, port=6969)
since_value = datetime.now(timezone.utc).isoformat()

alice = client.query("CreateUser", {"name": "Alice", "handle": "alice"})
bob = client.query("CreateUser", {"name": "Bob", "handle": "bobby"})

alice_id = alice[0]["user"]["id"]
bob_id = bob[0]["user"]["id"]

relationship = client.query("FollowUser", {
    "follower_id": alice_id,
    "followed_id": bob_id,
    "since": since_value,
})
relationship_id = relationship[0]["follow_edge"]["id"]

vector = client.query("GetFollowerVector", {
    "relationship_id": relationship_id,
})
print(vector)
```

```rust Rust [expandable]
use helix_rs::{HelixDB, HelixDBClient};
use serde_json::json;
use chrono::Utc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = HelixDB::new(Some("http://localhost"), Some(6969), None);
    let since_value = Utc::now().to_rfc3339();

    let alice: serde_json::Value = client.query("CreateUser", &json!({
        "name": "Alice",
        "handle": "alice",
    })).await?;
    let bob: serde_json::Value = client.query("CreateUser", &json!({
        "name": "Bob",
        "handle": "bobby",
    })).await?;

    let alice_id = alice["user"]["id"].as_str().unwrap().to_string();
    let bob_id = bob["user"]["id"].as_str().unwrap().to_string();

    let relationship: serde_json::Value = client.query("FollowUser", &json!({
        "follower_id": alice_id,
        "followed_id": bob_id,
        "since": since_value,
    })).await?;
    let relationship_id = relationship["follow_edge"]["id"].as_str().unwrap().to_string();

    let vector: serde_json::Value = client.query("GetFollowerVector", &json!({
        "relationship_id": relationship_id,
    })).await?;
    println!("GetFollowerVector result: {vector:#?}");

    Ok(())
}
```

```go Go [expandable]
package main

import (
    "fmt"
    "log"
    "time"

    "github.com/HelixDB/helix-go"
)

func main() {
    client := helix.NewClient("http://localhost:6969")
    sinceValue := time.Now().UTC().Format(time.RFC3339)

    var alice map[string]any
    if err := client.Query("CreateUser",
        helix.WithData(map[string]any{"name": "Alice", "handle": "alice"}),
    ).Scan(&alice); err != nil {
        log.Fatalf("CreateUser (Alice) failed: %s", err)
    }

    var bob map[string]any
    if err := client.Query("CreateUser",
        helix.WithData(map[string]any{"name": "Bob", "handle": "bobby"}),
    ).Scan(&bob); err != nil {
        log.Fatalf("CreateUser (Bob) failed: %s", err)
    }

    aliceID := alice["user"].(map[string]any)["id"].(string)
    bobID := bob["user"].(map[string]any)["id"].(string)

    var relationship map[string]any
    if err := client.Query("FollowUser",
        helix.WithData(map[string]any{
            "follower_id": aliceID,
            "followed_id": bobID,
            "since":       sinceValue,
        }),
    ).Scan(&relationship); err != nil {
        log.Fatalf("FollowUser failed: %s", err)
    }

    relationshipID := relationship["follow_edge"].(map[string]any)["id"].(string)

    var vector map[string]any
    if err := client.Query("GetFollowerVector",
        helix.WithData(map[string]any{"relationship_id": relationshipID}),
    ).Scan(&vector); err != nil {
        log.Fatalf("GetFollowerVector failed: %s", err)
    }

    fmt.Printf("GetFollowerVector result: %#v\n", vector)
}
```

```typescript TypeScript [expandable]
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");
    const sinceValue = new Date().toISOString();

    const alice = await client.query("CreateUser", {
        name: "Alice",
        handle: "alice",
    });
    const bob = await client.query("CreateUser", {
        name: "Bob",
        handle: "bobby",
    });

    const relationship = await client.query("FollowUser", {
        follower_id: alice.user.id,
        followed_id: bob.user.id,
        since: sinceValue,
    });

    const vector = await client.query("GetFollowerVector", {
        relationship_id: relationship.follow_edge.id,
    });

    console.log("GetFollowerVector result:", vector);
}

main().catch((err) => {
    console.error("GetFollowerVector query failed:", err);
});
```

```bash Curl [expandable]
alice=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","handle":"alice"}')
alice_id=$(echo "$alice" | jq -r '.user.id')

bob=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","handle":"bobby"}')
bob_id=$(echo "$bob" | jq -r '.user.id')

since=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

relationship=$(curl -s -X POST \
  http://localhost:6969/FollowUser \
  -H 'Content-Type: application/json' \
  -d '{"follower_id":"'"$alice_id"'","followed_id":"'"$bob_id"'","since":"'"$since"'"}')
relationship_id=$(echo "$relationship" | jq -r '.follow_edge.id')

curl -s -X POST \
  http://localhost:6969/GetFollowerVector \
  -H 'Content-Type: application/json' \
  -d '{"relationship_id":"'"$relationship_id"'"}'
```

</CodeGroup>

---

## `::ToN` &nbsp; Destination Node

Return the node that the edge points to.

```rust
::ToN
```

### Example 1: Getting the document node from an edge

<CodeGroup>
```rust Query focus={1-3} [expandable]
QUERY GetDocumentFromEdge (creation_id: ID) =>
    document <- E<Creates>(creation_id)::ToN
    RETURN document

QUERY CreateUser (name: String, email: String) =>
    user <- AddN<User>({
        name: name,
        email: email,
    })
    RETURN user

QUERY CreateDocument (user_id: ID, content: String, vector: [F64]) =>
    document <- AddV<Document>(vector, {
        content: content
    })
    creation_edge <- AddE<Creates>::From(user_id)::To(document)
    RETURN creation_edge
```

```rust Schema
N::User {
    name: String,
    email: String,
}

V::Document {
    content: String
}

E::Creates {
    From: User,
    To: Document
}
```

</CodeGroup>

<CodeGroup>
```python Python [expandable]
from helix.client import Client
from datetime import datetime, timezone

client = Client(local=True, port=6969)
since_value = datetime.now(timezone.utc).isoformat()

alice = client.query("CreateUser", {"name": "Alice", "handle": "alice"})
bob = client.query("CreateUser", {"name": "Bob", "handle": "bobby"})

alice_id = alice[0]["user"]["id"]
bob_id = bob[0]["user"]["id"]

relationship = client.query("FollowUser", {
    "follower_id": alice_id,
    "followed_id": bob_id,
    "since": since_value,
})
relationship_id = relationship[0]["follow_edge"]["id"]

followed = client.query("GetFollowedFromEdge", {
    "relationship_id": relationship_id,
})
print(followed)
```

```rust Rust [expandable]
use helix_rs::{HelixDB, HelixDBClient};
use serde_json::json;
use chrono::Utc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = HelixDB::new(Some("http://localhost"), Some(6969), None);
    let since_value = Utc::now().to_rfc3339();

    let alice: serde_json::Value = client.query("CreateUser", &json!({
        "name": "Alice",
        "handle": "alice",
    })).await?;
    let bob: serde_json::Value = client.query("CreateUser", &json!({
        "name": "Bob",
        "handle": "bobby",
    })).await?;

    let alice_id = alice["user"]["id"].as_str().unwrap().to_string();
    let bob_id = bob["user"]["id"].as_str().unwrap().to_string();

    let relationship: serde_json::Value = client.query("FollowUser", &json!({
        "follower_id": alice_id,
        "followed_id": bob_id,
        "since": since_value,
    })).await?;
    let relationship_id = relationship["follow_edge"]["id"].as_str().unwrap().to_string();

    let followed: serde_json::Value = client.query("GetFollowedFromEdge", &json!({
        "relationship_id": relationship_id,
    })).await?;
    println!("GetFollowedFromEdge result: {followed:#?}");

    Ok(())
}
```

```go Go [expandable]
package main

import (
    "fmt"
    "log"
    "time"

    "github.com/HelixDB/helix-go"
)

func main() {
    client := helix.NewClient("http://localhost:6969")
    sinceValue := time.Now().UTC().Format(time.RFC3339)

    var alice map[string]any
    if err := client.Query("CreateUser",
        helix.WithData(map[string]any{"name": "Alice", "handle": "alice"}),
    ).Scan(&alice); err != nil {
        log.Fatalf("CreateUser (Alice) failed: %s", err)
    }

    var bob map[string]any
    if err := client.Query("CreateUser",
        helix.WithData(map[string]any{"name": "Bob", "handle": "bobby"}),
    ).Scan(&bob); err != nil {
        log.Fatalf("CreateUser (Bob) failed: %s", err)
    }

    aliceID := alice["user"].(map[string]any)["id"].(string)
    bobID := bob["user"].(map[string]any)["id"].(string)

    var relationship map[string]any
    if err := client.Query("FollowUser",
        helix.WithData(map[string]any{
            "follower_id": aliceID,
            "followed_id": bobID,
            "since":       sinceValue,
        }),
    ).Scan(&relationship); err != nil {
        log.Fatalf("FollowUser failed: %s", err)
    }

    relationshipID := relationship["follow_edge"].(map[string]any)["id"].(string)

    var followed map[string]any
    if err := client.Query("GetFollowedFromEdge",
        helix.WithData(map[string]any{"relationship_id": relationshipID}),
    ).Scan(&followed); err != nil {
        log.Fatalf("GetFollowedFromEdge failed: %s", err)
    }

    fmt.Printf("GetFollowedFromEdge result: %#v\n", followed)
}
```

```typescript TypeScript [expandable]
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");
    const sinceValue = new Date().toISOString();

    const alice = await client.query("CreateUser", {
        name: "Alice",
        handle: "alice",
    });
    const bob = await client.query("CreateUser", {
        name: "Bob",
        handle: "bobby",
    });

    const relationship = await client.query("FollowUser", {
        follower_id: alice.user.id,
        followed_id: bob.user.id,
        since: sinceValue,
    });

    const followed = await client.query("GetFollowedFromEdge", {
        relationship_id: relationship.follow_edge.id,
    });

    console.log("GetFollowedFromEdge result:", followed);
}

main().catch((err) => {
    console.error("GetFollowedFromEdge query failed:", err);
});
```

```bash Curl [expandable]
alice=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","handle":"alice"}')
alice_id=$(echo "$alice" | jq -r '.user.id')

bob=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","handle":"bobby"}')
bob_id=$(echo "$bob" | jq -r '.user.id')

since=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

relationship=$(curl -s -X POST \
  http://localhost:6969/FollowUser \
  -H 'Content-Type: application/json' \
  -d '{"follower_id":"'"$alice_id"'","followed_id":"'"$bob_id"'","since":"'"$since"'"}')
relationship_id=$(echo "$relationship" | jq -r '.follow_edge.id')

curl -s -X POST \
  http://localhost:6969/GetFollowedFromEdge \
  -H 'Content-Type: application/json' \
  -d '{"relationship_id":"'"$relationship_id"'"}'
```

</CodeGroup>

---

## `::ToV` &nbsp; Destination Vector

Return the vector that the edge points to.

```rust
::ToV
```

### Example 1: Inspecting the document vector

<CodeGroup>
```rust Query focus={1-3} [expandable]
QUERY GetDocumentVector (creation_id: ID) =>
    document_vector <- E<Creates>(creation_id)::ToV
    RETURN document_vector

QUERY CreateUser (name: String, email: String) =>
    user <- AddN<User>({
        name: name,
        email: email,
    })
    RETURN user

QUERY CreateDocument (user_id: ID, content: String, vector: [F64]) =>
    document <- AddV<Document>(vector, {
        content: content
    })
    creation_edge <- AddE<Creates>::From(user_id)::To(document)
    RETURN creation_edge
```

```rust Schema
N::User {
    name: String,
    email: String,
}

V::Document {
    content: String
}

E::Creates {
    From: User,
    To: Document
}
```

</CodeGroup>

<CodeGroup>
```python Python [expandable]
from helix.client import Client
from datetime import datetime, timezone

client = Client(local=True, port=6969)
since_value = datetime.now(timezone.utc).isoformat()

alice = client.query("CreateUser", {"name": "Alice", "handle": "alice"})
bob = client.query("CreateUser", {"name": "Bob", "handle": "bobby"})

alice_id = alice[0]["user"]["id"]
bob_id = bob[0]["user"]["id"]

relationship = client.query("FollowUser", {
    "follower_id": alice_id,
    "followed_id": bob_id,
    "since": since_value,
})
relationship_id = relationship[0]["follow_edge"]["id"]

vector = client.query("GetFollowedVector", {
    "relationship_id": relationship_id,
})
print(vector)
```

```rust Rust [expandable]
use helix_rs::{HelixDB, HelixDBClient};
use serde_json::json;
use chrono::Utc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = HelixDB::new(Some("http://localhost"), Some(6969), None);
    let since_value = Utc::now().to_rfc3339();

    let alice: serde_json::Value = client.query("CreateUser", &json!({
        "name": "Alice",
        "handle": "alice",
    })).await?;
    let bob: serde_json::Value = client.query("CreateUser", &json!({
        "name": "Bob",
        "handle": "bobby",
    })).await?;

    let alice_id = alice["user"]["id"].as_str().unwrap().to_string();
    let bob_id = bob["user"]["id"].as_str().unwrap().to_string();

    let relationship: serde_json::Value = client.query("FollowUser", &json!({
        "follower_id": alice_id,
        "followed_id": bob_id,
        "since": since_value,
    })).await?;
    let relationship_id = relationship["follow_edge"]["id"].as_str().unwrap().to_string();

    let vector: serde_json::Value = client.query("GetFollowedVector", &json!({
        "relationship_id": relationship_id,
    })).await?;
    println!("GetFollowedVector result: {vector:#?}");

    Ok(())
}
```

```go Go [expandable]
package main

import (
    "fmt"
    "log"
    "time"

    "github.com/HelixDB/helix-go"
)

func main() {
    client := helix.NewClient("http://localhost:6969")
    sinceValue := time.Now().UTC().Format(time.RFC3339)

    var alice map[string]any
    if err := client.Query("CreateUser",
        helix.WithData(map[string]any{"name": "Alice", "handle": "alice"}),
    ).Scan(&alice); err != nil {
        log.Fatalf("CreateUser (Alice) failed: %s", err)
    }

    var bob map[string]any
    if err := client.Query("CreateUser",
        helix.WithData(map[string]any{"name": "Bob", "handle": "bobby"}),
    ).Scan(&bob); err != nil {
        log.Fatalf("CreateUser (Bob) failed: %s", err)
    }

    aliceID := alice["user"].(map[string]any)["id"].(string)
    bobID := bob["user"].(map[string]any)["id"].(string)

    var relationship map[string]any
    if err := client.Query("FollowUser",
        helix.WithData(map[string]any{
            "follower_id": aliceID,
            "followed_id": bobID,
            "since":       sinceValue,
        }),
    ).Scan(&relationship); err != nil {
        log.Fatalf("FollowUser failed: %s", err)
    }

    relationshipID := relationship["follow_edge"].(map[string]any)["id"].(string)

    var vector map[string]any
    if err := client.Query("GetFollowedVector",
        helix.WithData(map[string]any{"relationship_id": relationshipID}),
    ).Scan(&vector); err != nil {
        log.Fatalf("GetFollowedVector failed: %s", err)
    }

    fmt.Printf("GetFollowedVector result: %#v\n", vector)
}
```

```typescript TypeScript [expandable]
import HelixDB from "helix-ts";

async function main() {
    const client = new HelixDB("http://localhost:6969");
    const sinceValue = new Date().toISOString();

    const alice = await client.query("CreateUser", {
        name: "Alice",
        handle: "alice",
    });
    const bob = await client.query("CreateUser", {
        name: "Bob",
        handle: "bobby",
    });

    const relationship = await client.query("FollowUser", {
        follower_id: alice.user.id,
        followed_id: bob.user.id,
        since: sinceValue,
    });

    const vector = await client.query("GetFollowedVector", {
        relationship_id: relationship.follow_edge.id,
    });

    console.log("GetFollowedVector result:", vector);
}

main().catch((err) => {
    console.error("GetFollowedVector query failed:", err);
});
```

```bash Curl [expandable]
alice=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice","handle":"alice"}')
alice_id=$(echo "$alice" | jq -r '.user.id')

bob=$(curl -s -X POST \
  http://localhost:6969/CreateUser \
  -H 'Content-Type: application/json' \
  -d '{"name":"Bob","handle":"bobby"}')
bob_id=$(echo "$bob" | jq -r '.user.id')

since=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

relationship=$(curl -s -X POST \
  http://localhost:6969/FollowUser \
  -H 'Content-Type: application/json' \
  -d '{"follower_id":"'"$alice_id"'","followed_id":"'"$bob_id"'","since":"'"$since"'"}')
relationship_id=$(echo "$relationship" | jq -r '.follow_edge.id')

curl -s -X POST \
  http://localhost:6969/GetFollowedVector \
  -H 'Content-Type: application/json' \
  -d '{"relationship_id":"'"$relationship_id"'"}'
```

</CodeGroup>
